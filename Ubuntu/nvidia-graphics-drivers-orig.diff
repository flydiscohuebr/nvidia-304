diff -ruN nvidia-graphics-drivers/debian/changelog nvidia-graphics-drivers-edit/debian/changelog
--- nvidia-graphics-drivers/debian/changelog	2023-10-29 23:13:11.648261449 -0300
+++ nvidia-graphics-drivers-edit/debian/changelog	2023-10-29 23:12:58.554816941 -0300
@@ -1,3 +1,27 @@
+nvidia-graphics-drivers-304 (304.137-0ubuntu3) jammy; urgency=medium
+
+  * DKMS: Fix build kernel 6.5
+  * nvidia-304: Remove glamor.conf
+  * nvidia-304: Fix dpkg error unset variable on nvidia-304.postinst
+  * Revert nvidia-304: Depend on gcc-9
+
+ -- flydiscohuebr <fly@fly-VirtualBox>  Sun, 29 Oct 2023 22:01:43 -0300
+
+nvidia-graphics-drivers-304 (304.137-0ubuntu2+dokomix1) jammy; urgency=medium
+
+  * Backport for Jammy Jellyfish (22.04 LTS)
+  * nvidia-304: Depend on lib32gcc-s1 instead of lib32gcc1
+  * nvidia-304: Depend on gcc-9
+  * nvidia-opencl-icd-304: Drop dependency on nvidia-libopencl1-304
+  * Drop nvidia-libopencl1-304 package
+  * Drop nvidia-libopencl1-304-updates package
+  * DKMS: Build kernel module with gcc-9
+  * DKMS: Drop all upstream patches
+  * DKMS: Apply nvidia304/linux54-extramodules patches from
+    https://github.com/mirh/packages-legacy.git@f3640ca
+
+ -- Paul Preuss <paul@dokomi.de>  Sun, 30 Jan 2022 20:20:19 +0100
+
 nvidia-graphics-drivers-304 (304.137-0ubuntu2) bionic; urgency=medium
 
   * debian/dkms/patches/buildfix_kernel_4.14.patch:
diff -ruN nvidia-graphics-drivers/debian/compat nvidia-graphics-drivers-edit/debian/compat
--- nvidia-graphics-drivers/debian/compat	2023-10-29 23:13:11.648261449 -0300
+++ nvidia-graphics-drivers-edit/debian/compat	2023-10-29 17:01:15.000000000 -0300
@@ -1 +1 @@
-5
+10
diff -ruN nvidia-graphics-drivers/debian/control nvidia-graphics-drivers-edit/debian/control
--- nvidia-graphics-drivers/debian/control	2023-10-29 23:13:11.648261449 -0300
+++ nvidia-graphics-drivers-edit/debian/control	2023-10-29 23:07:26.000000000 -0300
@@ -12,7 +12,7 @@
 Package: nvidia-304
 Architecture: i386 amd64
 Depends: x11-common (>= 1:7.0.0), make, sed (>> 3.0), dkms, linux-libc-dev, libc6-dev,
- patch, acpid, lib32gcc1 [amd64], libc6-i386 [amd64],
+ patch, acpid, lib32gcc-s1 [amd64], libc6-i386 [amd64],
  xserver-xorg-legacy, ${shlibs:Depends}, ${misc:Depends}, ${xviddriver:Depends}
 Recommends: nvidia-settings (>= 331.20),
  libcuda1-304, nvidia-opencl-icd-304
@@ -62,24 +62,9 @@
  Supported NVIDIA devices include GPUs starting from GeForce 8 and Quadro FX
  series, as well as the Tesla computing processors.
 
-Package: nvidia-libopencl1-304
-Architecture: i386 amd64
-Depends: ${shlibs:Depends}, ${misc:Depends}
-Conflicts: libopencl1
-Replaces: libopencl1
-Provides: libopencl1
-Suggests: nvidia-opencl-icd-304
-Description: NVIDIA OpenCL Driver and ICD Loader library
- OpenCL (Open Computing Language) is a multivendor open standard for
- general-purpose parallel programming of heterogeneous systems that include
- CPUs, GPUs and other processors.
- .
- This package contains NVIDIA's OpenCL implementation and the ICD Loader
- library. This library supports only OpenCL 1.1.
-
 Package: nvidia-opencl-icd-304
 Architecture: i386 amd64
-Depends: ${shlibs:Depends}, ${misc:Depends}, ocl-icd-libopencl1 | nvidia-libopencl1-304
+Depends: ${shlibs:Depends}, ${misc:Depends}, ocl-icd-libopencl1
 Enhances: libopencl1
 Conflicts: nvidia-opencl-icd
 Replaces: nvidia-opencl-icd
@@ -106,13 +91,6 @@
  This is a transitional package for nvidia-304-dev, and can be
  safely removed after the installation is complete.
 
-Package: nvidia-libopencl1-304-updates
-Architecture: i386 amd64
-Depends: nvidia-libopencl1-304
-Description: Transitional package for nvidia-libopencl1-304
- This is a transitional package for nvidia-libopencl1-304, and can be
- safely removed after the installation is complete.
-
 Package: nvidia-opencl-icd-304-updates
 Architecture: i386 amd64
 Depends: nvidia-opencl-icd-304
diff -ruN nvidia-graphics-drivers/debian/dkms/patches/0001-disable-mtrr-4.3.patch nvidia-graphics-drivers-edit/debian/dkms/patches/0001-disable-mtrr-4.3.patch
--- nvidia-graphics-drivers/debian/dkms/patches/0001-disable-mtrr-4.3.patch	1969-12-31 21:00:00.000000000 -0300
+++ nvidia-graphics-drivers-edit/debian/dkms/patches/0001-disable-mtrr-4.3.patch	2023-10-29 16:26:15.000000000 -0300
@@ -0,0 +1,13 @@
+--- a/nv-linux.h
++++ b/nv-linux.h
+@@ -275,6 +275,10 @@
+ #include <linux/seq_file.h>
+ #endif
+ 
++#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,3,0)
++#undef CONFIG_MTRR
++#endif
++
+ #if !defined(NV_VMWARE) && defined(CONFIG_MTRR)
+ #include <asm/mtrr.h>
+ #endif
diff -ruN nvidia-graphics-drivers/debian/dkms/patches/0002-pud-offset-4.12.patch nvidia-graphics-drivers-edit/debian/dkms/patches/0002-pud-offset-4.12.patch
--- nvidia-graphics-drivers/debian/dkms/patches/0002-pud-offset-4.12.patch	1969-12-31 21:00:00.000000000 -0300
+++ nvidia-graphics-drivers-edit/debian/dkms/patches/0002-pud-offset-4.12.patch	2023-10-29 16:26:15.000000000 -0300
@@ -0,0 +1,77 @@
+--- a/nv-linux.h
++++ b/nv-linux.h
+@@ -1375,6 +1375,7 @@
+ 
+ #define NV_PAGE_MASK    (NvU64)(long)PAGE_MASK
+ 
++#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 12, 0)
+ #define NV_PGD_OFFSET(address, kernel, mm)              \
+    ({                                                   \
+         struct mm_struct *__mm = (mm);                  \
+@@ -1385,6 +1386,18 @@
+             __pgd = pgd_offset_k(address);              \
+         __pgd;                                          \
+     })
++#else
++#define NV_PGD_OFFSET(address, kernel, mm)              \
++   ({                                                   \
++        struct mm_struct *__mm = (mm);                  \
++        pgd_t *__pgd;                                   \
++        if (!kernel)                                    \
++            __pgd = pgd_offset(__mm, address);          \
++        else                                            \
++            __pgd = NULL;                               \
++        __pgd;                                          \
++    })
++#endif
+ 
+ #define NV_PGD_PRESENT(pgd)                             \
+    ({                                                   \
+@@ -1402,7 +1415,23 @@
+    })
+ #define NV_PMD_UNMAP(pmd) pmd_unmap(pmd);
+ #else
+-#if defined(PUD_SHIFT) /* 4-level pgtable */
++#if defined(P4D_SHIFT) /* 5-level pgtable */
++#define NV_PMD_OFFSET(address, pgd)                     \
++   ({                                                   \
++        pmd_t *__pmd = NULL;                            \
++        pud_t *__pud;                                   \
++        p4d_t *__p4d;                                   \
++        __p4d = p4d_offset(pgd, address);               \
++        if ((__p4d != NULL) &&                          \
++            !(p4d_bad(*__p4d) || p4d_none(*__p4d))) {   \
++            __pud = pud_offset(__p4d, address);         \
++            if ((__pud != NULL) &&                      \
++                !(pud_bad(*__pud) || pud_none(*__pud))) \
++                __pmd = pmd_offset(__pud, address);     \
++        }                                               \
++        __pmd;                                          \
++    })
++#elif defined(PUD_SHIFT) /* 4-level pgtable */
+ #define NV_PMD_OFFSET(address, pgd)                     \
+    ({                                                   \
+         pmd_t *__pmd = NULL;                            \
+--- a/nv-vtophys.c
++++ b/nv-vtophys.c
+@@ -81,10 +81,20 @@
+ #endif
+ 
+     /* direct-mapped kernel address */
++#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 12, 0)
+     if ((address > PAGE_OFFSET) && (address < VMALLOC_START))
++#else
++    if (virt_addr_valid(address))
++#endif
+         return __pa(address);
+ 
++#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 12, 0)
+     return nv_get_phys_address(address, TRUE);
++#else
++    nv_printf(NV_DBG_ERRORS,
++        "NVRM: can't translate address in %s()!\n", __FUNCTION__);
++    return 0;
++#endif
+ }
+ 
+ NvU64 NV_API_CALL nv_get_user_address(NvU64 address)
diff -ruN nvidia-graphics-drivers/debian/dkms/patches/0003-nvidia-drm-pci-init-4.14.patch nvidia-graphics-drivers-edit/debian/dkms/patches/0003-nvidia-drm-pci-init-4.14.patch
--- nvidia-graphics-drivers/debian/dkms/patches/0003-nvidia-drm-pci-init-4.14.patch	1969-12-31 21:00:00.000000000 -0300
+++ nvidia-graphics-drivers-edit/debian/dkms/patches/0003-nvidia-drm-pci-init-4.14.patch	2023-10-29 16:26:15.000000000 -0300
@@ -0,0 +1,34 @@
+--- a/nv-drm.c
++++ b/nv-drm.c
+@@ -22,6 +22,8 @@
+ #include <drm/drm_gem.h>
+ #endif
+ 
++#include <linux/version.h>
++
+ extern nv_linux_state_t *nv_linux_devices;
+ 
+ static int nv_drm_load(
+@@ -121,7 +123,11 @@
+ {
+     int ret = 0;
+ #if defined(NV_DRM_AVAILABLE)
++#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0)
+     ret = drm_pci_init(&nv_drm_driver, pci_driver);
++#else
++    ret = drm_legacy_pci_init(&nv_drm_driver, pci_driver);
++#endif
+ #endif
+     return ret;
+ }
+@@ -131,6 +137,10 @@
+ )
+ {
+ #if defined(NV_DRM_AVAILABLE)
++#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0)
+     drm_pci_exit(&nv_drm_driver, pci_driver);
++#else
++    drm_legacy_pci_exit(&nv_drm_driver, pci_driver);
++#endif
+ #endif
+ }
diff -ruN nvidia-graphics-drivers/debian/dkms/patches/0004-timer-4.15.patch nvidia-graphics-drivers-edit/debian/dkms/patches/0004-timer-4.15.patch
--- nvidia-graphics-drivers/debian/dkms/patches/0004-timer-4.15.patch	1969-12-31 21:00:00.000000000 -0300
+++ nvidia-graphics-drivers-edit/debian/dkms/patches/0004-timer-4.15.patch	2023-10-29 16:26:15.000000000 -0300
@@ -0,0 +1,56 @@
+--- a/nv.c
++++ b/nv.c
+@@ -17,6 +17,8 @@
+ #include "rmil.h"
+ #include "nv-pat.h"
+ 
++#include <linux/version.h>
++
+ #if defined(MODULE_LICENSE)
+ MODULE_LICENSE("NVIDIA");
+ #endif
+@@ -301,7 +303,11 @@
+ #else
+ irqreturn_t   nv_kern_isr(int, void *);
+ #endif
++#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+ void          nv_kern_rc_timer(unsigned long);
++#else
++void          nv_kern_rc_timer(struct timer_list *);
++#endif
+ #if defined(NV_PM_SUPPORT_OLD_STYLE_APM)
+ static int    nv_kern_apm_event(struct pm_dev *, pm_request_t, void *);
+ #endif
+@@ -2075,10 +2081,18 @@
+ }
+ 
+ void nv_kern_rc_timer(
++#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+     unsigned long data
++#else
++    struct timer_list *t_list
++#endif
+ )
+ {
++#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+     nv_linux_state_t *nvl = (nv_linux_state_t *) data;
++#else
++    nv_linux_state_t *nvl = from_timer(nvl, t_list, rc_timer);
++#endif
+     nv_state_t *nv = NV_STATE_PTR(nvl);
+ 
+     NV_CHECK_PCI_CONFIG_SPACE(nvl->timer_sp, nv, TRUE, TRUE, FALSE);
+@@ -3029,9 +3043,13 @@
+         return -1;
+ 
+     nv_printf(NV_DBG_INFO, "NVRM: initializing rc timer\n");
++#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0)
+     init_timer(&nvl->rc_timer);
+     nvl->rc_timer.function = nv_kern_rc_timer;
+     nvl->rc_timer.data = (unsigned long) nv;
++#else
++    timer_setup(&nvl->rc_timer, nv_kern_rc_timer, 0);
++#endif
+     nv->rc_timer_enabled = 1;
+     mod_timer(&nvl->rc_timer, jiffies + HZ); /* set our timeout for 1 second */
+     nv_printf(NV_DBG_INFO, "NVRM: rc timer initialized\n");
diff -ruN nvidia-graphics-drivers/debian/dkms/patches/0005-usercopy-4.16.patch nvidia-graphics-drivers-edit/debian/dkms/patches/0005-usercopy-4.16.patch
--- nvidia-graphics-drivers/debian/dkms/patches/0005-usercopy-4.16.patch	1969-12-31 21:00:00.000000000 -0300
+++ nvidia-graphics-drivers-edit/debian/dkms/patches/0005-usercopy-4.16.patch	2023-10-29 16:26:15.000000000 -0300
@@ -0,0 +1,39 @@
+--- a/nv.c
++++ b/nv.c
+@@ -874,7 +874,11 @@
+     NV_SPIN_LOCK_INIT(&km_lock);
+ #endif
+ 
++#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 16, 0)
+     NV_KMEM_CACHE_CREATE(nv_stack_t_cache, "nv_stack_t", nv_stack_t);
++#else
++    NV_KMEM_CACHE_CREATE_USERCOPY(nv_stack_t_cache, "nv_stack_t", nv_stack_t);
++#endif
+     if (nv_stack_t_cache == NULL)
+     {
+         nv_printf(NV_DBG_ERRORS, "NVRM: stack cache allocation failed!\n");
+--- a/nv-linux.h
++++ b/nv-linux.h
+@@ -844,12 +844,22 @@
+         kmem_cache = kmem_cache_create(name, sizeof(type),      \
+                         0, 0, NULL, NULL);                      \
+     }
++#define NV_KMEM_CACHE_CREATE_USERCOPY(kmem_cache, name, type)            \
++    {                                                                    \
++        kmem_cache = kmem_cache_create_usercopy(name, sizeof(type),      \
++                        0, 0, 0, sizeof(type), NULL, NULL);              \
++    }
+ #elif (NV_KMEM_CACHE_CREATE_ARGUMENT_COUNT == 5)
+ #define NV_KMEM_CACHE_CREATE(kmem_cache, name, type)            \
+     {                                                           \
+         kmem_cache = kmem_cache_create(name, sizeof(type),      \
+                         0, 0, NULL);                            \
+     }
++#define NV_KMEM_CACHE_CREATE_USERCOPY(kmem_cache, name, type)            \
++    {                                                                    \
++        kmem_cache = kmem_cache_create_usercopy(name, sizeof(type),      \
++                        0, 0, 0, sizeof(type), NULL);                    \
++    }
+ #else
+ #error "NV_KMEM_CACHE_CREATE_ARGUMENT_COUNT value unrecognized!"
+ #endif
diff -ruN nvidia-graphics-drivers/debian/dkms/patches/0006-do_gettimeofday-5.0.patch nvidia-graphics-drivers-edit/debian/dkms/patches/0006-do_gettimeofday-5.0.patch
--- nvidia-graphics-drivers/debian/dkms/patches/0006-do_gettimeofday-5.0.patch	1969-12-31 21:00:00.000000000 -0300
+++ nvidia-graphics-drivers-edit/debian/dkms/patches/0006-do_gettimeofday-5.0.patch	2023-10-29 16:26:15.000000000 -0300
@@ -0,0 +1,143 @@
+--- a/nv-drm.c
++++ b/nv-drm.c
+@@ -96,7 +96,7 @@
+ };
+ 
+ static struct drm_driver nv_drm_driver = {
+-#if defined(DRIVER_LEGACY)
++#if defined(DRIVER_LEGACY) || LINUX_VERSION_CODE >= KERNEL_VERSION(5, 0, 0)
+     .driver_features = DRIVER_LEGACY,
+ #else
+     .driver_features = 0,
+--- a/nv.h
++++ b/nv.h
+@@ -465,27 +465,27 @@
+ 
+ #define NV_TIMERCMP(a, b, CMP)                                              \
+     (((a)->tv_sec == (b)->tv_sec) ?                                         \
+-        ((a)->tv_usec CMP (b)->tv_usec) : ((a)->tv_sec CMP (b)->tv_sec))
++        ((a)->tv_nsec CMP (b)->tv_nsec) : ((a)->tv_sec CMP (b)->tv_sec))
+ 
+ #define NV_TIMERADD(a, b, result)                                           \
+     {                                                                       \
+         (result)->tv_sec = (a)->tv_sec + (b)->tv_sec;                       \
+-        (result)->tv_usec = (a)->tv_usec + (b)->tv_usec;                    \
+-        if ((result)->tv_usec >= 1000000)                                   \
++        (result)->tv_nsec = (a)->tv_nsec + (b)->tv_nsec;                    \
++        if ((result)->tv_nsec >= NSEC_PER_SEC)                              \
+         {                                                                   \
+             ++(result)->tv_sec;                                             \
+-            (result)->tv_usec -= 1000000;                                   \
++            (result)->tv_nsec -= NSEC_PER_SEC;                              \
+         }                                                                   \
+     }
+ 
+ #define NV_TIMERSUB(a, b, result)                                           \
+     {                                                                       \
+         (result)->tv_sec = (a)->tv_sec - (b)->tv_sec;                       \
+-        (result)->tv_usec = (a)->tv_usec - (b)->tv_usec;                    \
+-        if ((result)->tv_usec < 0)                                          \
++        (result)->tv_nsec = (a)->tv_nsec - (b)->tv_nsec;                    \
++        if ((result)->tv_nsec < 0)                                          \
+         {                                                                   \
+           --(result)->tv_sec;                                               \
+-          (result)->tv_usec += 1000000;                                     \
++          (result)->tv_nsec += NSEC_PER_SEC;                                \
+         }                                                                   \
+     }
+ 
+--- a/os-interface.c
++++ b/os-interface.c
+@@ -662,12 +662,12 @@
+     NvU32 *useconds
+ )
+ {
+-    struct timeval tm;
++    struct timespec64 tm;
+ 
+-    do_gettimeofday(&tm);
++    ktime_get_real_ts64(&tm);
+ 
+     *seconds = tm.tv_sec;
+-    *useconds = tm.tv_usec;
++    *useconds = tm.tv_nsec / NSEC_PER_USEC;
+ 
+     return RM_OK;
+ }
+@@ -697,9 +697,9 @@
+     unsigned long usec;
+ 
+ #ifdef NV_CHECK_DELAY_ACCURACY
+-    struct timeval tm1, tm2;
++    struct timespec64 tm1, tm2;
+ 
+-    do_gettimeofday(&tm1);
++    ktime_get_real_ts64(&tm1);
+ #endif
+ 
+     if (in_irq() && (MicroSeconds > NV_MAX_ISR_DELAY_US))
+@@ -714,9 +714,9 @@
+         udelay(usec);
+ 
+ #ifdef NV_CHECK_DELAY_ACCURACY
+-    do_gettimeofday(&tm2);
++    ktime_get_real_ts64(&tm2);
+     nv_printf(NV_DBG_ERRORS, "NVRM: osDelayUs %d: 0x%x 0x%x\n",
+-        MicroSeconds, tm2.tv_sec - tm1.tv_sec, tm2.tv_usec - tm1.tv_usec);
++        MicroSeconds, tm2.tv_sec - tm1.tv_sec, tm2.tv_nsec - tm1.tv_nsec);
+ #endif
+ 
+     return RM_OK;
+@@ -737,12 +737,12 @@
+     unsigned long MicroSeconds;
+     unsigned long jiffies;
+     unsigned long mdelay_safe_msec;
+-    struct timeval tm_end, tm_aux;
++    struct timespec64 tm_end, tm_aux;
+ #ifdef NV_CHECK_DELAY_ACCURACY
+-    struct timeval tm_start;
++    struct timespec64 tm_start;
+ #endif
+ 
+-    do_gettimeofday(&tm_aux);
++    ktime_get_real_ts64(&tm_aux);
+ #ifdef NV_CHECK_DELAY_ACCURACY
+     tm_start = tm_aux;
+ #endif
+@@ -757,7 +757,7 @@
+     }
+ 
+     MicroSeconds = MilliSeconds * 1000;
+-    tm_end.tv_usec = MicroSeconds;
++    tm_end.tv_nsec = MicroSeconds * NSEC_PER_USEC;
+     tm_end.tv_sec = 0;
+     NV_TIMERADD(&tm_aux, &tm_end, &tm_end);
+ 
+@@ -776,11 +776,11 @@
+         do
+         {
+             schedule_timeout(jiffies);
+-            do_gettimeofday(&tm_aux);
++            ktime_get_real_ts64(&tm_aux);
+             if (NV_TIMERCMP(&tm_aux, &tm_end, <))
+             {
+                 NV_TIMERSUB(&tm_end, &tm_aux, &tm_aux);
+-                MicroSeconds = tm_aux.tv_usec + tm_aux.tv_sec * 1000000;
++                MicroSeconds = tm_aux.tv_nsec / NSEC_PER_USEC + tm_aux.tv_sec * USEC_PER_SEC;
+             }
+             else
+                 MicroSeconds = 0;
+@@ -798,10 +798,10 @@
+         udelay(MicroSeconds);
+     }
+ #ifdef NV_CHECK_DELAY_ACCURACY
+-    do_gettimeofday(&tm_aux);
++    ktime_get_real_ts64(&tm_aux);
+     timersub(&tm_aux, &tm_start, &tm_aux);
+-    nv_printf(NV_DBG_ERRORS, "NVRM: osDelay %dmsec: %d.%06dsec\n",
+-        MilliSeconds, tm_aux.tv_sec, tm_aux.tv_usec);
++    nv_printf(NV_DBG_ERRORS, "NVRM: osDelay %dmsec: %d.%09dsec\n",
++        MilliSeconds, tm_aux.tv_sec, tm_aux.tv_nsec);
+ #endif
+ 
+     return RM_OK;
diff -ruN nvidia-graphics-drivers/debian/dkms/patches/0007-subdirs-5.3.patch nvidia-graphics-drivers-edit/debian/dkms/patches/0007-subdirs-5.3.patch
--- nvidia-graphics-drivers/debian/dkms/patches/0007-subdirs-5.3.patch	1969-12-31 21:00:00.000000000 -0300
+++ nvidia-graphics-drivers-edit/debian/dkms/patches/0007-subdirs-5.3.patch	2023-10-29 18:11:11.000000000 -0300
@@ -0,0 +1,11 @@
+--- a/Makefile.kbuild
++++ b/Makefile.kbuild
+@@ -231,7 +231,7 @@
+ endif
+ 
+ KBUILD_PARAMS += KBUILD_VERBOSE=$(NV_VERBOSE)
+-KBUILD_PARAMS += -C $(KERNEL_SOURCES) SUBDIRS=$(PWD)
++KBUILD_PARAMS += -C $(KERNEL_SOURCES) M=$(PWD)
+ KBUILD_PARAMS += ARCH=$(ARCH)
+ 
+ #
diff -ruN nvidia-graphics-drivers/debian/dkms/patches/0008-on-each-cpu-5.3.patch nvidia-graphics-drivers-edit/debian/dkms/patches/0008-on-each-cpu-5.3.patch
--- nvidia-graphics-drivers/debian/dkms/patches/0008-on-each-cpu-5.3.patch	1969-12-31 21:00:00.000000000 -0300
+++ nvidia-graphics-drivers-edit/debian/dkms/patches/0008-on-each-cpu-5.3.patch	2023-10-29 16:26:15.000000000 -0300
@@ -0,0 +1,46 @@
+--- a/nv-linux.h
++++ b/nv-linux.h
+@@ -991,12 +991,21 @@
+         __ret;                                               \
+      })
+ #elif (NV_SMP_CALL_FUNCTION_ARGUMENT_COUNT == 3)
++#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 3, 0)
+ #define NV_SMP_CALL_FUNCTION(func, info, wait)               \
+     ({                                                       \
+         int __ret = smp_call_function(func, info, wait);     \
+         __ret;                                               \
+      })
+ #else
++#define NV_SMP_CALL_FUNCTION(func, info, wait)               \
++    ({                                                       \
++        int __ret = 0;                                       \
++        smp_call_function(func, info, wait);                 \
++        __ret;                                               \
++     })
++#endif
++#else
+ #error "NV_SMP_CALL_FUNCTION_ARGUMENT_COUNT value unrecognized!"
+ #endif
+ #elif defined(CONFIG_SMP)
+@@ -1011,12 +1020,21 @@
+         __ret;                                         \
+      })
+ #elif (NV_ON_EACH_CPU_ARGUMENT_COUNT == 3)
++#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 3, 0)
+ #define NV_ON_EACH_CPU(func, info, wait)               \
+     ({                                                 \
+         int __ret = on_each_cpu(func, info, wait);     \
+         __ret;                                         \
+      })
+ #else
++#define NV_ON_EACH_CPU(func, info, wait)               \
++    ({                                                 \
++        int __ret = 0;                                 \
++        on_each_cpu(func, info, wait);                 \
++        __ret;                                         \
++    })
++#endif
++#else
+ #error "NV_ON_EACH_CPU_ARGUMENT_COUNT value unrecognized!"
+ #endif
+ #elif !defined(KERNEL_2_4) && defined(CONFIG_SMP)
diff -ruN nvidia-graphics-drivers/debian/dkms/patches/0009-remove-drmp-5.5.patch nvidia-graphics-drivers-edit/debian/dkms/patches/0009-remove-drmp-5.5.patch
--- nvidia-graphics-drivers/debian/dkms/patches/0009-remove-drmp-5.5.patch	1969-12-31 21:00:00.000000000 -0300
+++ nvidia-graphics-drivers-edit/debian/dkms/patches/0009-remove-drmp-5.5.patch	2023-10-29 16:26:15.000000000 -0300
@@ -0,0 +1,59 @@
+--- a/conftest.sh
++++ b/conftest.sh
+@@ -1493,6 +1493,9 @@
+             CODE="
+             #if defined(NV_DRM_DRMP_H_PRESENT)
+             #include <drm/drmP.h>
++            #else
++            #include <drm/drm_drv.h>
++            #include <drm/drm_prime.h>
+             #endif
+             #if !defined(CONFIG_DRM) && !defined(CONFIG_DRM_MODULE)
+             #error DRM not enabled
+@@ -1940,6 +1943,8 @@
+             CODE="
+             #if defined(NV_DRM_DRMP_H_PRESENT)
+             #include <drm/drmP.h>
++            #else
++            #include <drm/drm_drv.h>
+             #endif
+             void conftest_drm_pci_set_busid(void) {
+                 drm_pci_set_busid();
+@@ -2098,8 +2103,11 @@
+             #   2017-01-06  11b3c20bdd15d17382068be569740de1dccb173d
+             #
+             CODE="
++            #if defined(NV_DRM_DRMP_H_PRESENT)
+             #include <drm/drmP.h>
+-
++            #else
++            #include <drm/drm_drv.h>
++            #endif
+             int conftest_drm_driver_unload_has_int_return_type(struct drm_driver *drv) {
+                 return drv->unload(NULL /* dev */);
+             }"
+--- a/nv-drm.c
++++ b/nv-drm.c
+@@ -16,7 +16,22 @@
+ 
+ #if defined(NV_DRM_AVAILABLE)
+ 
++#if defined(NV_DRM_DRMP_H_PRESENT)
+ #include <drm/drmP.h>
++#else
++#include <uapi/drm/drm.h>
++#include <uapi/drm/drm_mode.h>
++
++#include <drm/drm_agpsupport.h>
++#include <drm/drm_crtc.h>
++#include <drm/drm_drv.h>
++#include <drm/drm_prime.h>
++#include <drm/drm_pci.h>
++#include <drm/drm_ioctl.h>
++#include <drm/drm_sysfs.h>
++#include <drm/drm_vblank.h>
++#include <drm/drm_device.h>
++#endif
+ 
+ #if defined(NV_DRM_DRM_GEM_H_PRESENT)
+ #include <drm/drm_gem.h>
diff -ruN nvidia-graphics-drivers/debian/dkms/patches/0010-proc-ops-5.6.patch nvidia-graphics-drivers-edit/debian/dkms/patches/0010-proc-ops-5.6.patch
--- nvidia-graphics-drivers/debian/dkms/patches/0010-proc-ops-5.6.patch	1969-12-31 21:00:00.000000000 -0300
+++ nvidia-graphics-drivers-edit/debian/dkms/patches/0010-proc-ops-5.6.patch	2023-10-29 21:24:55.000000000 -0300
@@ -0,0 +1,221 @@
+--- a/conftest.sh
++++ b/conftest.sh
+@@ -1151,6 +1151,22 @@
+             compile_check_conftest "$CODE" "NV_IOREMAP_CACHE_PRESENT" "" "functions"
+         ;;
+ 
++        ioremap_nocache)
++            #
++            # Determine if the ioremap_nocache() function is present.
++            #
++            # Removed by commit 4bdc0d676a64 ("remove ioremap_nocache and
++            # devm_ioremap_nocache") in v5.6 (2020-01-06)
++            #
++            CODE="
++            #include <asm/io.h>
++            void conftest_ioremap_nocache(void) {
++                ioremap_nocache();
++            }"
++
++            compile_check_conftest "$CODE" "NV_IOREMAP_NOCACHE_PRESENT" "" "functions"
++        ;;
++
+         ioremap_wc)
+             #
+             # Determine if the ioremap_wc() function is present.
+@@ -1359,6 +1375,16 @@
+             compile_check_conftest "$CODE" "NV_FILE_OPERATIONS_HAS_COMPAT_IOCTL" "" "types"
+         ;;
+ 
++        proc_ops)
++            CODE="
++            #include <linux/proc_fs.h>
++            int conftest_proc_ops(void) {
++                return offsetof(struct proc_ops, proc_open);
++            }"
++
++            compile_check_conftest "$CODE" "NV_HAVE_PROC_OPS" "" "types"
++        ;;
++
+         sg_init_table)
+             #
+             # Determine if the sg_init_table() function is present.
+--- a/Makefile.kbuild
++++ b/Makefile.kbuild
+@@ -165,6 +165,7 @@
+ 	vmm_support \
+ 	acpi_evaluate_integer \
+ 	ioremap_cache \
++	ioremap_nocache \
+ 	ioremap_wc \
+ 	proc_dir_entry \
+ 	INIT_WORK \
+@@ -174,6 +175,7 @@
+ 	pci_domain_nr \
+ 	pci_dma_mapping_error \
+ 	file_operations \
++	proc_ops \
+ 	sg_init_table \
+ 	pci_get_domain_bus_and_slot \
+ 	get_num_physpages \
+--- a/nv-drm.c
++++ b/nv-drm.c
+@@ -140,8 +140,35 @@
+ #if defined(NV_DRM_AVAILABLE)
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0)
+     ret = drm_pci_init(&nv_drm_driver, pci_driver);
+-#else
++#elif LINUX_VERSION_CODE < KERNEL_VERSION(5, 6, 0)
+     ret = drm_legacy_pci_init(&nv_drm_driver, pci_driver);
++#else
++    struct pci_dev *pdev = NULL;
++    const struct pci_device_id *pid;
++    int i;
++
++    INIT_LIST_HEAD(&nv_drm_driver.legacy_dev_list);
++        for (i = 0; pci_driver->id_table[i].vendor != 0; i++) {
++                pid = &pci_driver->id_table[i];
++
++        /* Loop around setting up a DRM device for each PCI device
++         * matching our ID and device class.  If we had the internal
++         * function that pci_get_subsys and pci_get_class used, we'd
++         * be able to just pass pid in instead of doing a two-stage
++         * thing.
++         */
++                pdev = NULL;
++                while ((pdev =
++                        pci_get_subsys(pid->vendor, pid->device, pid->subvendor,
++                                       pid->subdevice, pdev)) != NULL) {
++                        if ((pdev->class & pid->class_mask) != pid->class)
++                                continue;
++
++                        /* stealth mode requires a manual probe */
++                        pci_dev_get(pdev);
++                        drm_get_pci_dev(pdev, pid, &nv_drm_driver);
++                }
++        }
+ #endif
+ #endif
+     return ret;
+@@ -154,8 +181,15 @@
+ #if defined(NV_DRM_AVAILABLE)
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0)
+     drm_pci_exit(&nv_drm_driver, pci_driver);
+-#else
++#elif LINUX_VERSION_CODE < KERNEL_VERSION(5, 6, 0)
+     drm_legacy_pci_exit(&nv_drm_driver, pci_driver);
++#else
++    struct drm_device *dev, *tmp;
++    list_for_each_entry_safe(dev, tmp, &nv_drm_driver.legacy_dev_list, legacy_dev_list) {
++        list_del(&dev->legacy_dev_list);
++        drm_put_dev(dev);
++    }
++    DRM_INFO("Module unloaded\n");
+ #endif
+ #endif
+ }
+--- a/nv-linux.h
++++ b/nv-linux.h
+@@ -772,11 +772,15 @@
+         VM_ALLOC_RECORD(ptr, size, "vm_ioremap"); \
+     }
+ 
++#if defined(NV_IOREMAP_NOCACHE_PRESENT)
+ #define NV_IOREMAP_NOCACHE(ptr, physaddr, size) \
+     { \
+         (ptr) = ioremap_nocache(physaddr, size); \
+         VM_ALLOC_RECORD(ptr, size, "vm_ioremap_nocache"); \
+     }
++#else
++#define NV_IOREMAP_NOCACHE NV_IOREMAP
++#endif
+ 
+ #if defined(NV_IOREMAP_CACHE_PRESENT)
+ #define NV_IOREMAP_CACHE(ptr, physaddr, size)            \
+--- a/nv-procfs.c
++++ b/nv-procfs.c
+@@ -69,6 +69,19 @@
+     })
+ #endif
+ 
++#if defined(NV_HAVE_PROC_OPS)
++#define NV_CREATE_PROC_FILE(filename,parent,__name,__data)               \
++   ({                                                                    \
++        struct proc_dir_entry *__entry;                                  \
++        int __mode = (S_IFREG | S_IRUGO);                                \
++        const struct proc_ops *fops = &nv_procfs_##__name##_fops;        \
++        if (fops->proc_write != 0)                                       \
++            __mode |= S_IWUSR;                                           \
++        __entry = proc_create_data(filename, __mode, parent, fops,       \
++            __data);                                                     \
++        __entry;                                                         \
++    })
++#else
+ #define NV_CREATE_PROC_FILE(filename,parent,__name,__data)               \
+    ({                                                                    \
+         struct proc_dir_entry *__entry;                                  \
+@@ -80,6 +93,7 @@
+             __data);                                                     \
+         __entry;                                                         \
+     })
++#endif
+ 
+ /*
+  * proc_mkdir_mode exists in Linux 2.6.9, but isn't exported until Linux 3.0.
+@@ -113,6 +127,24 @@
+ # define NV_PDE_DATA(inode) PDE(inode)->data
+ #endif
+ 
++#if defined(NV_HAVE_PROC_OPS)
++#define NV_DEFINE_PROCFS_SINGLE_FILE(__name)                                  \
++    static int nv_procfs_open_##__name(                                       \
++        struct inode *inode,                                                  \
++        struct file *filep                                                    \
++    )                                                                         \
++    {                                                                         \
++        return single_open(filep, nv_procfs_read_##__name,                    \
++            NV_PDE_DATA(inode));                                              \
++    }                                                                         \
++                                                                              \
++    static const struct proc_ops nv_procfs_##__name##_fops = {                \
++        .proc_open       = nv_procfs_open_##__name,                           \
++        .proc_read       = seq_read,                                          \
++        .proc_lseek      = seq_lseek,                                         \
++        .proc_release    = single_release,                                    \
++    };
++#else
+ #define NV_DEFINE_PROCFS_SINGLE_FILE(__name)                                  \
+     static int nv_procfs_open_##__name(                                       \
+         struct inode *inode,                                                  \
+@@ -130,6 +162,7 @@
+         .llseek     = seq_lseek,                                              \
+         .release    = single_release,                                         \
+     };
++#endif
+ 
+ static int nv_procfs_read_registry(struct seq_file *s, void *v);
+ 
+@@ -660,6 +693,15 @@
+     return ((status < 0) ? status : (int)count);
+ }
+ 
++#if defined(NV_HAVE_PROC_OPS)
++static struct proc_ops nv_procfs_registry_fops = {
++    .proc_open    = nv_procfs_open_registry,
++    .proc_read    = seq_read,
++    .proc_write   = nv_procfs_write_registry,
++    .proc_lseek   = seq_lseek,
++    .proc_release = nv_procfs_close_registry,
++};
++#else
+ static struct file_operations nv_procfs_registry_fops = {
+     .owner   = THIS_MODULE,
+     .open    = nv_procfs_open_registry,
+@@ -668,6 +710,7 @@
+     .llseek  = seq_lseek,
+     .release = nv_procfs_close_registry,
+ };
++#endif
+ 
+ static int
+ nv_procfs_read_text_file(
diff -ruN nvidia-graphics-drivers/debian/dkms/patches/0011-kernel-5.7.0-setmemoryarray.patch nvidia-graphics-drivers-edit/debian/dkms/patches/0011-kernel-5.7.0-setmemoryarray.patch
--- nvidia-graphics-drivers/debian/dkms/patches/0011-kernel-5.7.0-setmemoryarray.patch	1969-12-31 21:00:00.000000000 -0300
+++ nvidia-graphics-drivers-edit/debian/dkms/patches/0011-kernel-5.7.0-setmemoryarray.patch	2023-10-29 16:26:15.000000000 -0300
@@ -0,0 +1,29 @@
+--- NVIDIA-Linux-x86_64-304.137mod2/conftest.sh	2022-01-08 17:42:05.315884362 -0300
++++ NVIDIA-Linux-x86_64-304.137mod1/conftest.sh	2022-01-08 17:52:56.140500898 -0300
+@@ -342,6 +342,8 @@
+             # Determine if the set_memory_uc() function is present.
+             #
+             CODE="
++            #include <asm/page.h>
++            #include <asm/pgtable.h>
+             #if defined(NV_ASM_SET_MEMORY_H_PRESENT)
+             #include <asm/set_memory.h>
+             #else
+@@ -359,6 +361,8 @@
+             # Determine if the set_memory_array_uc() function is present.
+             #
+             CODE="
++            #include <asm/page.h>
++            #include <asm/pgtable.h>
+             #if defined(NV_ASM_SET_MEMORY_H_PRESENT)
+             #include <asm/set_memory.h>
+             #else
+@@ -376,6 +380,8 @@
+             # Determine if the set_pages_uc() function is present.
+             #
+             CODE="
++            #include <asm/page.h>
++            #include <asm/pgtable.h>
+             #if defined(NV_ASM_SET_MEMORY_H_PRESENT)
+             #include <asm/set_memory.h>
+             #else
diff -ruN nvidia-graphics-drivers/debian/dkms/patches/0012-kernel5.8.patch nvidia-graphics-drivers-edit/debian/dkms/patches/0012-kernel5.8.patch
--- nvidia-graphics-drivers/debian/dkms/patches/0012-kernel5.8.patch	1969-12-31 21:00:00.000000000 -0300
+++ nvidia-graphics-drivers-edit/debian/dkms/patches/0012-kernel5.8.patch	2023-10-29 22:23:37.000000000 -0300
@@ -0,0 +1,64 @@
+diff -ruN NVIDIA-Linux-x86_64-304.137p1/kernel/Makefile.kbuild NVIDIA-Linux-x86_64-304.137p2/kernel/Makefile.kbuild
+--- NVIDIA-Linux-x86_64-304.137p1/Makefile.kbuild	2022-01-10 19:57:07.375477089 -0300
++++ NVIDIA-Linux-x86_64-304.137p2/Makefile.kbuild	2022-01-10 20:03:04.463853427 -0300
+@@ -261,6 +261,7 @@
+ 
+ module: build-sanity-checks
+ 	@echo "NVIDIA: calling KBUILD..."; \
++	touch .nv-kernel.o.cmd; \
+ 	 $(MAKE) "CC=$(CC)" $(KBUILD_PARAMS) modules; \
+ 	echo "NVIDIA: left KBUILD."; \
+ 	if ! [ -f $(MODULE_OBJECT) ]; then \
+diff -ruN NVIDIA-Linux-x86_64-304.137p1/kernel/nv-drm.c NVIDIA-Linux-x86_64-304.137p2/kernel/nv-drm.c
+--- NVIDIA-Linux-x86_64-304.137p1/nv-drm.c	2022-01-10 19:57:07.375477089 -0300
++++ NVIDIA-Linux-x86_64-304.137p2/nv-drm.c	2022-01-10 20:00:59.509670334 -0300
+@@ -26,7 +26,6 @@
+ #include <drm/drm_crtc.h>
+ #include <drm/drm_drv.h>
+ #include <drm/drm_prime.h>
+-#include <drm/drm_pci.h>
+ #include <drm/drm_ioctl.h>
+ #include <drm/drm_sysfs.h>
+ #include <drm/drm_vblank.h>
+diff -ruN NVIDIA-Linux-x86_64-304.137p1/kernel/nv-mlock.c NVIDIA-Linux-x86_64-304.137p2/kernel/nv-mlock.c
+--- NVIDIA-Linux-x86_64-304.137p1/nv-mlock.c	2017-09-14 17:51:09.000000000 -0300
++++ NVIDIA-Linux-x86_64-304.137p2/nv-mlock.c	2022-01-10 20:02:17.517551323 -0300
+@@ -47,12 +47,19 @@
+                 "NVRM: failed to allocate page table!\n");
+         return rmStatus;
+     }
+-
++#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 8, 0)
++    down_read(&mm->mmap_lock);
++    ret = NV_GET_USER_PAGES((unsigned long)address,
++                            page_count, write, force, user_pages, NULL);
++    up_read(&mm->mmap_lock);
++    pinned = ret;
++#else
+     down_read(&mm->mmap_sem);
+     ret = NV_GET_USER_PAGES((unsigned long)address,
+                             page_count, write, force, user_pages, NULL);
+     up_read(&mm->mmap_sem);
+     pinned = ret;
++#endif
+ 
+     if (ret < 0)
+     {
+diff -ruN NVIDIA-Linux-x86_64-304.137p1/kernel/nv-pat.c NVIDIA-Linux-x86_64-304.137p2/kernel/nv-pat.c
+--- NVIDIA-Linux-x86_64-304.137p1/nv-pat.c	2017-09-14 17:51:09.000000000 -0300
++++ NVIDIA-Linux-x86_64-304.137p2/nv-pat.c	2022-01-10 20:04:03.850642030 -0300
+@@ -38,14 +38,12 @@
+     wbinvd();
+     *cr4 = NV_READ_CR4();
+     if (*cr4 & 0x80) NV_WRITE_CR4(*cr4 & ~0x80);
+-    __flush_tlb();
+ }
+ 
+ static inline void nv_enable_caches(unsigned long cr4)
+ {
+     unsigned long cr0 = read_cr0();
+     wbinvd();
+-    __flush_tlb();
+     write_cr0((cr0 & 0x9fffffff));
+     if (cr4 & 0x80) NV_WRITE_CR4(cr4);
+ }
diff -ruN nvidia-graphics-drivers/debian/dkms/patches/0013-kernel5.9.patch nvidia-graphics-drivers-edit/debian/dkms/patches/0013-kernel5.9.patch
--- nvidia-graphics-drivers/debian/dkms/patches/0013-kernel5.9.patch	1969-12-31 21:00:00.000000000 -0300
+++ nvidia-graphics-drivers-edit/debian/dkms/patches/0013-kernel5.9.patch	2023-10-29 16:26:15.000000000 -0300
@@ -0,0 +1,46 @@
+diff -ruN NVIDIA-Linux-x86_64-304.137p1/kernel/nv.c NVIDIA-Linux-x86_64-304.137p2/kernel/nv.c
+--- NVIDIA-Linux-x86_64-304.137p1/nv.c	2022-01-10 19:56:50.706995715 -0300
++++ NVIDIA-Linux-x86_64-304.137p2/nv.c	2022-01-10 20:07:39.959220633 -0300
+@@ -3327,8 +3327,12 @@
+ 
+ #if defined(CONFIG_VGA_ARB)
+ #if defined(VGA_DEFAULT_DEVICE)
++#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 9, 0)
++    vga_get(VGA_DEFAULT_DEVICE, VGA_RSRC_LEGACY_MASK, 0);
++#else
+     vga_tryget(VGA_DEFAULT_DEVICE, VGA_RSRC_LEGACY_MASK);
+ #endif
++#endif
+     vga_set_legacy_decoding(dev, VGA_RSRC_NONE);
+ #endif
+ 
+diff -ruN NVIDIA-Linux-x86_64-304.137p1/kernel/nv-linux.h NVIDIA-Linux-x86_64-304.137p2/kernel/nv-linux.h
+--- NVIDIA-Linux-x86_64-304.137p1/nv-linux.h	2022-01-10 19:57:07.377477338 -0300
++++ NVIDIA-Linux-x86_64-304.137p2/nv-linux.h	2022-01-10 20:09:33.516806031 -0300
+@@ -152,8 +152,10 @@
+ 
+ #if defined(NVCPU_X86_64) && !defined(KERNEL_2_4) && !defined(HAVE_COMPAT_IOCTL)
+ #include <linux/syscalls.h>         /* sys_ioctl()                      */
++#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 9, 0)
+ #include <linux/ioctl32.h>          /* register_ioctl32_conversion()    */
+ #endif
++#endif
+ 
+ #if defined(NVCPU_X86_64) && defined(KERNEL_2_4)
+ #include <asm/ioctl32.h>            /* sys_ioctl() (ioctl32)            */
+@@ -1979,10 +1981,13 @@
+                                             pages, vmas, NULL);
+ 
+         #else
+-
++	#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 9, 0)
++               return get_user_pages_remote(mm, start, nr_pages, flags,
++                                            pages, vmas, NULL);
++	#else
+                return get_user_pages_remote(tsk, mm, start, nr_pages, flags,
+                                             pages, vmas);
+-
++	#endif
+         #endif
+ 
+         }
diff -ruN nvidia-graphics-drivers/debian/dkms/patches/0014-import-drm_legacy_pci_init-exit-from-src-linux-5.9.1.patch nvidia-graphics-drivers-edit/debian/dkms/patches/0014-import-drm_legacy_pci_init-exit-from-src-linux-5.9.1.patch
--- nvidia-graphics-drivers/debian/dkms/patches/0014-import-drm_legacy_pci_init-exit-from-src-linux-5.9.1.patch	1969-12-31 21:00:00.000000000 -0300
+++ nvidia-graphics-drivers-edit/debian/dkms/patches/0014-import-drm_legacy_pci_init-exit-from-src-linux-5.9.1.patch	2023-10-29 16:26:15.000000000 -0300
@@ -0,0 +1,297 @@
+diff -ruN NVIDIA-Linux-x86_64-304.137p2/kernel/nv-drm.c NVIDIA-Linux-x86_64-304.137p1/kernel/nv-drm.c
+--- NVIDIA-Linux-x86_64-304.137p2/nv-drm.c	2022-01-26 16:01:13.774925221 -0300
++++ NVIDIA-Linux-x86_64-304.137p1/nv-drm.c	2022-01-26 16:11:18.979707020 -0300
+@@ -8,6 +8,81 @@
+  * _NVRM_COPYRIGHT_END_
+  */
+ 
++// copied from src:linux (5.9.11-1) drivers/gpu/drm/drm_legacy.h
++/*
++ * Copyright (c) 2014 David Herrmann <dh.herrmann@gmail.com>
++ *
++ * Permission is hereby granted, free of charge, to any person obtaining a
++ * copy of this software and associated documentation files (the "Software"),
++ * to deal in the Software without restriction, including without limitation
++ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
++ * and/or sell copies of the Software, and to permit persons to whom the
++ * Software is furnished to do so, subject to the following conditions:
++ *
++ * The above copyright notice and this permission notice shall be included in
++ * all copies or substantial portions of the Software.
++ *
++ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
++ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
++ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
++ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
++ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
++ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
++ * OTHER DEALINGS IN THE SOFTWARE.
++ */
++
++// copied from src:linux (5.9.11-1) drivers/gpu/drm/drm_pci.c
++/*
++ * Copyright 2003 Jos√© Fonseca.
++ * Copyright 2003 Leif Delgass.
++ * All Rights Reserved.
++ *
++ * Permission is hereby granted, free of charge, to any person obtaining a
++ * copy of this software and associated documentation files (the "Software"),
++ * to deal in the Software without restriction, including without limitation
++ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
++ * and/or sell copies of the Software, and to permit persons to whom the
++ * Software is furnished to do so, subject to the following conditions:
++ *
++ * The above copyright notice and this permission notice (including the next
++ * paragraph) shall be included in all copies or substantial portions of the
++ * Software.
++ *
++ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
++ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
++ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
++ * AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
++ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
++ * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
++ */
++
++// copied from src:linux (5.9.11-1) drivers/gpu/drm/drm_agpsupport.c
++// copied from src:linux (5.9.11-1) drivers/gpu/drm/drm_memory.c
++/*
++ * Copyright 1999 Precision Insight, Inc., Cedar Park, Texas.
++ * Copyright 2000 VA Linux Systems, Inc., Sunnyvale, California.
++ * All Rights Reserved.
++ *
++ * Permission is hereby granted, free of charge, to any person obtaining a
++ * copy of this software and associated documentation files (the "Software"),
++ * to deal in the Software without restriction, including without limitation
++ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
++ * and/or sell copies of the Software, and to permit persons to whom the
++ * Software is furnished to do so, subject to the following conditions:
++ *
++ * The above copyright notice and this permission notice (including the next
++ * paragraph) shall be included in all copies or substantial portions of the
++ * Software.
++ *
++ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
++ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
++ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
++ * VA LINUX SYSTEMS AND/OR ITS SUPPLIERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
++ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
++ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
++ * OTHER DEALINGS IN THE SOFTWARE.
++ */
++
+ #define  __NO_VERSION__
+ 
+ #include "nv-misc.h"
+@@ -38,6 +113,211 @@
+ 
+ #include <linux/version.h>
+ 
++// copied from src:linux (5.9.11-1) drivers/gpu/drm/drm_legacy.h
++struct drm_agp_mem {
++	unsigned long handle;
++	struct agp_memory *memory;
++	unsigned long bound;
++	int pages;
++	struct list_head head;
++};
++
++// copied from src:linux (5.9.11-1) drivers/gpu/drm/drm_memory.c
++/** Wrapper around agp_free_memory() */
++void drm_free_agp(struct agp_memory *handle, int pages)
++{
++	agp_free_memory(handle);
++}
++
++// copied from src:linux (5.9.11-1) drivers/gpu/drm/drm_memory.c
++/** Wrapper around agp_unbind_memory() */
++int drm_unbind_agp(struct agp_memory *handle)
++{
++	return agp_unbind_memory(handle);
++}
++
++// copied from src:linux (5.9.11-1) drivers/gpu/drm/drm_pci.c
++static void drm_pci_agp_init(struct drm_device *dev)
++{
++	if (drm_core_check_feature(dev, DRIVER_USE_AGP)) {
++		if (pci_find_capability(dev->pdev, PCI_CAP_ID_AGP))
++			dev->agp = drm_agp_init(dev);
++		if (dev->agp) {
++			dev->agp->agp_mtrr = arch_phys_wc_add(
++				dev->agp->agp_info.aper_base,
++				dev->agp->agp_info.aper_size *
++				1024 * 1024);
++		}
++	}
++}
++
++// copied from src:linux (5.9.11-1) drivers/gpu/drm/drm_agpsupport.c
++/**
++ * drm_legacy_agp_clear - Clear AGP resource list
++ * @dev: DRM device
++ *
++ * Iterate over all AGP resources and remove them. But keep the AGP head
++ * intact so it can still be used. It is safe to call this if AGP is disabled or
++ * was already removed.
++ *
++ * Cleanup is only done for drivers who have DRIVER_LEGACY set.
++ */
++void drm_legacy_agp_clear(struct drm_device *dev)
++{
++	struct drm_agp_mem *entry, *tempe;
++
++	if (!dev->agp)
++		return;
++	if (!drm_core_check_feature(dev, DRIVER_LEGACY))
++		return;
++
++	list_for_each_entry_safe(entry, tempe, &dev->agp->memory, head) {
++		if (entry->bound)
++			drm_unbind_agp(entry->memory);
++		drm_free_agp(entry->memory, entry->pages);
++		kfree(entry);
++	}
++	INIT_LIST_HEAD(&dev->agp->memory);
++
++	if (dev->agp->acquired)
++		drm_agp_release(dev);
++
++	dev->agp->acquired = 0;
++	dev->agp->enabled = 0;
++}
++
++// copied from src:linux (5.9.11-1) drivers/gpu/drm/drm_pci.c
++void drm_pci_agp_destroy(struct drm_device *dev)
++{
++	if (dev->agp) {
++		arch_phys_wc_del(dev->agp->agp_mtrr);
++		drm_legacy_agp_clear(dev);
++		kfree(dev->agp);
++		dev->agp = NULL;
++	}
++}
++
++// copied from src:linux (5.9.11-1) drivers/gpu/drm/drm_pci.c
++static int drm_get_pci_dev(struct pci_dev *pdev,
++			   const struct pci_device_id *ent,
++			   struct drm_driver *driver)
++{
++	struct drm_device *dev;
++	int ret;
++
++	DRM_DEBUG("\n");
++
++	dev = drm_dev_alloc(driver, &pdev->dev);
++	if (IS_ERR(dev))
++		return PTR_ERR(dev);
++
++	ret = pci_enable_device(pdev);
++	if (ret)
++		goto err_free;
++
++	dev->pdev = pdev;
++#ifdef __alpha__
++	dev->hose = pdev->sysdata;
++#endif
++
++	if (drm_core_check_feature(dev, DRIVER_MODESET))
++		pci_set_drvdata(pdev, dev);
++
++	drm_pci_agp_init(dev);
++
++	ret = drm_dev_register(dev, ent->driver_data);
++	if (ret)
++		goto err_agp;
++
++	/* No locking needed since shadow-attach is single-threaded since it may
++	 * only be called from the per-driver module init hook. */
++	if (drm_core_check_feature(dev, DRIVER_LEGACY))
++		list_add_tail(&dev->legacy_dev_list, &driver->legacy_dev_list);
++
++	return 0;
++
++err_agp:
++	drm_pci_agp_destroy(dev);
++	pci_disable_device(pdev);
++err_free:
++	drm_dev_put(dev);
++	return ret;
++}
++
++// copied from src:linux (5.9.11-1) drivers/gpu/drm/drm_pci.c
++/**
++ * drm_legacy_pci_init - shadow-attach a legacy DRM PCI driver
++ * @driver: DRM device driver
++ * @pdriver: PCI device driver
++ *
++ * This is only used by legacy dri1 drivers and deprecated.
++ *
++ * Return: 0 on success or a negative error code on failure.
++ */
++int drm_legacy_pci_init(struct drm_driver *driver, struct pci_driver *pdriver)
++{
++	struct pci_dev *pdev = NULL;
++	const struct pci_device_id *pid;
++	int i;
++
++	DRM_DEBUG("\n");
++
++	if (WARN_ON(!(driver->driver_features & DRIVER_LEGACY)))
++		return -EINVAL;
++
++	/* If not using KMS, fall back to stealth mode manual scanning. */
++	INIT_LIST_HEAD(&driver->legacy_dev_list);
++	for (i = 0; pdriver->id_table[i].vendor != 0; i++) {
++		pid = &pdriver->id_table[i];
++
++		/* Loop around setting up a DRM device for each PCI device
++		 * matching our ID and device class.  If we had the internal
++		 * function that pci_get_subsys and pci_get_class used, we'd
++		 * be able to just pass pid in instead of doing a two-stage
++		 * thing.
++		 */
++		pdev = NULL;
++		while ((pdev =
++			pci_get_subsys(pid->vendor, pid->device, pid->subvendor,
++				       pid->subdevice, pdev)) != NULL) {
++			if ((pdev->class & pid->class_mask) != pid->class)
++				continue;
++
++			/* stealth mode requires a manual probe */
++			pci_dev_get(pdev);
++			drm_get_pci_dev(pdev, pid, driver);
++		}
++	}
++	return 0;
++}
++
++// copied from src:linux (5.9.11-1) drivers/gpu/drm/drm_pci.c
++/**
++ * drm_legacy_pci_exit - unregister shadow-attach legacy DRM driver
++ * @driver: DRM device driver
++ * @pdriver: PCI device driver
++ *
++ * Unregister a DRM driver shadow-attached through drm_legacy_pci_init(). This
++ * is deprecated and only used by dri1 drivers.
++ */
++void drm_legacy_pci_exit(struct drm_driver *driver, struct pci_driver *pdriver)
++{
++	struct drm_device *dev, *tmp;
++
++	DRM_DEBUG("\n");
++
++	if (!(driver->driver_features & DRIVER_LEGACY)) {
++		WARN_ON(1);
++	} else {
++		list_for_each_entry_safe(dev, tmp, &driver->legacy_dev_list,
++					 legacy_dev_list) {
++			list_del(&dev->legacy_dev_list);
++			drm_put_dev(dev);
++		}
++	}
++	DRM_INFO("Module unloaded\n");
++}
++
+ extern nv_linux_state_t *nv_linux_devices;
+ 
+ static int nv_drm_load(
diff -ruN nvidia-graphics-drivers/debian/dkms/patches/0015-add-static-and-nv_-prefix-to-copied-drm-legacy-bits.patch nvidia-graphics-drivers-edit/debian/dkms/patches/0015-add-static-and-nv_-prefix-to-copied-drm-legacy-bits.patch
--- nvidia-graphics-drivers/debian/dkms/patches/0015-add-static-and-nv_-prefix-to-copied-drm-legacy-bits.patch	1969-12-31 21:00:00.000000000 -0300
+++ nvidia-graphics-drivers-edit/debian/dkms/patches/0015-add-static-and-nv_-prefix-to-copied-drm-legacy-bits.patch	2023-10-29 16:26:15.000000000 -0300
@@ -0,0 +1,175 @@
+diff -ruN NVIDIA-Linux-x86_64-304.137/kernel/conftest.sh NVIDIA-Linux-x86_64-304.1371/kernel/conftest.sh
+--- NVIDIA-Linux-x86_64-304.137/conftest.sh	2022-01-10 21:21:52.000000000 -0300
++++ NVIDIA-Linux-x86_64-304.1371/conftest.sh	2022-01-10 23:50:11.888740725 -0300
+@@ -92,6 +92,7 @@
+     FILES="asm/system.h"
+     FILES="$FILES drm/drmP.h"
+     FILES="$FILES drm/drm_gem.h"
++    FILES="$FILES drm/drm_agpsupport.h"
+     FILES="$FILES generated/autoconf.h"
+     FILES="$FILES generated/compile.h"
+     FILES="$FILES generated/utsrelease.h"
+diff -ruN NVIDIA-Linux-x86_64-304.137/kernel/nv-drm.c NVIDIA-Linux-x86_64-304.1371/kernel/nv-drm.c
+--- NVIDIA-Linux-x86_64-304.137/nv-drm.c	2022-01-10 21:21:00.000000000 -0300
++++ NVIDIA-Linux-x86_64-304.1371/nv-drm.c	2022-01-11 00:00:06.996868670 -0300
+@@ -107,6 +107,10 @@
+ #include <drm/drm_device.h>
+ #endif
+ 
++#if defined(NV_DRM_DRM_AGPSUPPORT_H_PRESENT)
++#include <drm/drm_agpsupport.h>
++#endif
++
+ #if defined(NV_DRM_DRM_GEM_H_PRESENT)
+ #include <drm/drm_gem.h>
+ #endif
+@@ -114,7 +118,7 @@
+ #include <linux/version.h>
+ 
+ // copied from src:linux (5.9.11-1) drivers/gpu/drm/drm_legacy.h
+-struct drm_agp_mem {
++struct nv_drm_agp_mem {
+ 	unsigned long handle;
+ 	struct agp_memory *memory;
+ 	unsigned long bound;
+@@ -122,22 +126,24 @@
+ 	struct list_head head;
+ };
+ 
++static inline
+ // copied from src:linux (5.9.11-1) drivers/gpu/drm/drm_memory.c
+ /** Wrapper around agp_free_memory() */
+-void drm_free_agp(struct agp_memory *handle, int pages)
++void nv_drm_free_agp(struct agp_memory *handle, int pages)
+ {
+ 	agp_free_memory(handle);
+ }
+ 
++static inline
+ // copied from src:linux (5.9.11-1) drivers/gpu/drm/drm_memory.c
+ /** Wrapper around agp_unbind_memory() */
+-int drm_unbind_agp(struct agp_memory *handle)
++int nv_drm_unbind_agp(struct agp_memory *handle)
+ {
+ 	return agp_unbind_memory(handle);
+ }
+ 
+ // copied from src:linux (5.9.11-1) drivers/gpu/drm/drm_pci.c
+-static void drm_pci_agp_init(struct drm_device *dev)
++static void nv_drm_pci_agp_init(struct drm_device *dev)
+ {
+ 	if (drm_core_check_feature(dev, DRIVER_USE_AGP)) {
+ 		if (pci_find_capability(dev->pdev, PCI_CAP_ID_AGP))
+@@ -151,6 +157,7 @@
+ 	}
+ }
+ 
++static
+ // copied from src:linux (5.9.11-1) drivers/gpu/drm/drm_agpsupport.c
+ /**
+  * drm_legacy_agp_clear - Clear AGP resource list
+@@ -162,9 +169,9 @@
+  *
+  * Cleanup is only done for drivers who have DRIVER_LEGACY set.
+  */
+-void drm_legacy_agp_clear(struct drm_device *dev)
++void nv_drm_legacy_agp_clear(struct drm_device *dev)
+ {
+-	struct drm_agp_mem *entry, *tempe;
++	struct nv_drm_agp_mem *entry, *tempe;
+ 
+ 	if (!dev->agp)
+ 		return;
+@@ -173,8 +180,8 @@
+ 
+ 	list_for_each_entry_safe(entry, tempe, &dev->agp->memory, head) {
+ 		if (entry->bound)
+-			drm_unbind_agp(entry->memory);
+-		drm_free_agp(entry->memory, entry->pages);
++			nv_drm_unbind_agp(entry->memory);
++		nv_drm_free_agp(entry->memory, entry->pages);
+ 		kfree(entry);
+ 	}
+ 	INIT_LIST_HEAD(&dev->agp->memory);
+@@ -186,19 +193,20 @@
+ 	dev->agp->enabled = 0;
+ }
+ 
++static
+ // copied from src:linux (5.9.11-1) drivers/gpu/drm/drm_pci.c
+-void drm_pci_agp_destroy(struct drm_device *dev)
++void nv_drm_pci_agp_destroy(struct drm_device *dev)
+ {
+ 	if (dev->agp) {
+ 		arch_phys_wc_del(dev->agp->agp_mtrr);
+-		drm_legacy_agp_clear(dev);
++		nv_drm_legacy_agp_clear(dev);
+ 		kfree(dev->agp);
+ 		dev->agp = NULL;
+ 	}
+ }
+ 
+ // copied from src:linux (5.9.11-1) drivers/gpu/drm/drm_pci.c
+-static int drm_get_pci_dev(struct pci_dev *pdev,
++static int nv_drm_get_pci_dev(struct pci_dev *pdev,
+ 			   const struct pci_device_id *ent,
+ 			   struct drm_driver *driver)
+ {
+@@ -223,7 +231,7 @@
+ 	if (drm_core_check_feature(dev, DRIVER_MODESET))
+ 		pci_set_drvdata(pdev, dev);
+ 
+-	drm_pci_agp_init(dev);
++	nv_drm_pci_agp_init(dev);
+ 
+ 	ret = drm_dev_register(dev, ent->driver_data);
+ 	if (ret)
+@@ -237,13 +245,14 @@
+ 	return 0;
+ 
+ err_agp:
+-	drm_pci_agp_destroy(dev);
++	nv_drm_pci_agp_destroy(dev);
+ 	pci_disable_device(pdev);
+ err_free:
+ 	drm_dev_put(dev);
+ 	return ret;
+ }
+ 
++static
+ // copied from src:linux (5.9.11-1) drivers/gpu/drm/drm_pci.c
+ /**
+  * drm_legacy_pci_init - shadow-attach a legacy DRM PCI driver
+@@ -254,7 +263,7 @@
+  *
+  * Return: 0 on success or a negative error code on failure.
+  */
+-int drm_legacy_pci_init(struct drm_driver *driver, struct pci_driver *pdriver)
++int nv_drm_pci_init(struct drm_driver *driver, struct pci_driver *pdriver)
+ {
+ 	struct pci_dev *pdev = NULL;
+ 	const struct pci_device_id *pid;
+@@ -285,12 +294,13 @@
+ 
+ 			/* stealth mode requires a manual probe */
+ 			pci_dev_get(pdev);
+-			drm_get_pci_dev(pdev, pid, driver);
++			nv_drm_get_pci_dev(pdev, pid, driver);
+ 		}
+ 	}
+ 	return 0;
+ }
+ 
++static
+ // copied from src:linux (5.9.11-1) drivers/gpu/drm/drm_pci.c
+ /**
+  * drm_legacy_pci_exit - unregister shadow-attach legacy DRM driver
+@@ -300,7 +310,7 @@
+  * Unregister a DRM driver shadow-attached through drm_legacy_pci_init(). This
+  * is deprecated and only used by dri1 drivers.
+  */
+-void drm_legacy_pci_exit(struct drm_driver *driver, struct pci_driver *pdriver)
++void nv_drm_pci_exit(struct drm_driver *driver, struct pci_driver *pdriver)
+ {
+ 	struct drm_device *dev, *tmp;
+ 
diff -ruN nvidia-graphics-drivers/debian/dkms/patches/0016-vmalloc5.9.patch nvidia-graphics-drivers-edit/debian/dkms/patches/0016-vmalloc5.9.patch
--- nvidia-graphics-drivers/debian/dkms/patches/0016-vmalloc5.9.patch	1969-12-31 21:00:00.000000000 -0300
+++ nvidia-graphics-drivers-edit/debian/dkms/patches/0016-vmalloc5.9.patch	2023-10-29 21:26:55.000000000 -0300
@@ -0,0 +1,64 @@
+diff -ruN NVIDIA-Linux-x86_64-304.137p1/kernel/conftest.sh NVIDIA-Linux-x86_64-304.137p2/kernel/conftest.sh
+--- NVIDIA-Linux-x86_64-304.137p1/conftest.sh	2022-01-10 19:58:03.420698411 -0300
++++ NVIDIA-Linux-x86_64-304.137p2/conftest.sh	2022-01-10 20:14:31.819275538 -0300
+@@ -2147,6 +2147,25 @@
+ 
+             compile_check_conftest "$CODE" "NV_DRM_DRIVER_UNLOAD_HAS_INT_RETURN_TYPE" "" "types"
+         ;;
++        vmalloc_has_pgprot_t_arg)
++            #
++            # Determine if __vmalloc has the 'pgprot' argument.
++            #
++            # The third argument to __vmalloc, page protection
++            # 'pgprot_t prot', was removed by commit 88dca4ca5a93
++            # (mm: remove the pgprot argument to __vmalloc)
++            # in v5.8-rc1 (2020-06-01).
++        CODE="
++        #include <linux/vmalloc.h>
++
++        void conftest_vmalloc_has_pgprot_t_arg(void) {
++            pgprot_t prot;
++            (void)__vmalloc(0, 0, prot);
++        }"
++
++            compile_check_conftest "$CODE" "NV_VMALLOC_HAS_PGPROT_T_ARG" "" "types"
++
++        ;;
+     esac
+ }
+ 
+diff -ruN NVIDIA-Linux-x86_64-304.137p1/kernel/Makefile.kbuild NVIDIA-Linux-x86_64-304.137p2/kernel/Makefile.kbuild
+--- NVIDIA-Linux-x86_64-304.137p1/Makefile.kbuild	2022-01-10 20:06:16.023060754 -0300
++++ NVIDIA-Linux-x86_64-304.137p2/Makefile.kbuild	2022-01-10 20:12:36.237940297 -0300
+@@ -196,6 +196,7 @@
+ 	cpuhp_setup_state \
+ 	vm_fault_present \
+ 	vm_fault_has_address \
++	vmalloc_has_pgprot_t_arg \
+ 	drm_driver_unload_has_int_return_type
+ #
+ # Miscellaneous NVIDIA kernel module build support targets. They are needed
+diff -ruN NVIDIA-Linux-x86_64-304.137p1/kernel/nv-linux.h NVIDIA-Linux-x86_64-304.137p2/kernel/nv-linux.h
+--- NVIDIA-Linux-x86_64-304.137p1/nv-linux.h	2022-01-10 20:10:56.250987626 -0300
++++ NVIDIA-Linux-x86_64-304.137p2/nv-linux.h	2022-01-10 20:30:27.538087869 -0300
+@@ -719,12 +719,20 @@
+ #endif
+ 
+ #if defined(NVCPU_X86) || defined(NVCPU_X86_64)
++#if defined(NV_VMALLOC_HAS_PGPROT_T_ARG)
+ #define NV_VMALLOC(ptr, size, cached)                                   \
+     {                                                                   \
+         pgprot_t __prot = (cached) ? PAGE_KERNEL : PAGE_KERNEL_NOCACHE; \
+         (ptr) = __vmalloc(size, GFP_KERNEL, __prot);                    \
+         VM_ALLOC_RECORD(ptr, size, "vm_vmalloc");                       \
+     }
++#else
++#define NV_VMALLOC(ptr, size, cached)                       \
++    {                                                       \
++        (ptr) = __vmalloc(size, GFP_KERNEL);                \
++        VM_ALLOC_RECORD(ptr, size, "vm_vmalloc");           \
++    }
++#endif
+ #elif defined(NVCPU_ARM)
+ #define NV_VMALLOC_CACHE(ptr, size)                                     \
+     {                                                                   \
diff -ruN nvidia-graphics-drivers/debian/dkms/patches/0017-patch-14-kernel-5.11.patch nvidia-graphics-drivers-edit/debian/dkms/patches/0017-patch-14-kernel-5.11.patch
--- nvidia-graphics-drivers/debian/dkms/patches/0017-patch-14-kernel-5.11.patch	1969-12-31 21:00:00.000000000 -0300
+++ nvidia-graphics-drivers-edit/debian/dkms/patches/0017-patch-14-kernel-5.11.patch	2023-10-29 16:26:15.000000000 -0300
@@ -0,0 +1,13 @@
+--- 1/nv-linux.h	2017-09-14 17:51:09.000000000 -0300
++++ 2/nv-linux.h	2021-12-25 20:26:19.821461438 -0300
+@@ -134,7 +134,9 @@
+ #include <asm/tlbflush.h>           /* flush_tlb(), flush_tlb_all()     */
+ #include <linux/cpu.h>              /* CPU hotplug support              */
+ #endif
+-#include <asm/kmap_types.h>         /* page table entry lookup          */
++#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 11, 0)
++	#include <asm/kmap_types.h>         /* page table entry lookup          */
++#endif
+ #endif
+ 
+ #include <linux/pci.h>              /* pci_find_class, etc              */
diff -ruN nvidia-graphics-drivers/debian/dkms/patches/0018-kernel5.14.patch nvidia-graphics-drivers-edit/debian/dkms/patches/0018-kernel5.14.patch
--- nvidia-graphics-drivers/debian/dkms/patches/0018-kernel5.14.patch	1969-12-31 21:00:00.000000000 -0300
+++ nvidia-graphics-drivers-edit/debian/dkms/patches/0018-kernel5.14.patch	2023-10-29 16:26:15.000000000 -0300
@@ -0,0 +1,15 @@
+diff -ruN NVIDIA-Linux-x86_64-304.137p1/kernel/os-interface.c NVIDIA-Linux-x86_64-304.137p2/kernel/os-interface.c
+--- NVIDIA-Linux-x86_64-304.137p1/os-interface.c	2022-01-10 19:56:53.451468695 -0300
++++ NVIDIA-Linux-x86_64-304.137p2/os-interface.c	2022-01-10 20:34:22.677245200 -0300
+@@ -772,7 +772,11 @@
+         // the requested timeout has expired, loop until less
+         // than a jiffie of the desired delay remains.
+         //
++#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 14, 0)
++        current->__state = TASK_INTERRUPTIBLE;
++#else
+         current->state = TASK_INTERRUPTIBLE;
++#endif
+         do
+         {
+             schedule_timeout(jiffies);
diff -ruN nvidia-graphics-drivers/debian/dkms/patches/0019-fix-mistake.patch nvidia-graphics-drivers-edit/debian/dkms/patches/0019-fix-mistake.patch
--- nvidia-graphics-drivers/debian/dkms/patches/0019-fix-mistake.patch	1969-12-31 21:00:00.000000000 -0300
+++ nvidia-graphics-drivers-edit/debian/dkms/patches/0019-fix-mistake.patch	2023-10-29 16:26:15.000000000 -0300
@@ -0,0 +1,11 @@
+--- testp1/nv-drm.c	2022-06-08 15:55:54.032770000 -0300
++++ testp2/nv-drm.c	2022-06-08 15:59:29.207131531 -0300
+@@ -455,7 +455,7 @@
+ 
+                         /* stealth mode requires a manual probe */
+                         pci_dev_get(pdev);
+-                        drm_get_pci_dev(pdev, pid, &nv_drm_driver);
++                        nv_drm_get_pci_dev(pdev, pid, &nv_drm_driver);
+                 }
+         }
+ #endif
diff -ruN nvidia-graphics-drivers/debian/dkms/patches/0019-kernel-5.16.patch nvidia-graphics-drivers-edit/debian/dkms/patches/0019-kernel-5.16.patch
--- nvidia-graphics-drivers/debian/dkms/patches/0019-kernel-5.16.patch	1969-12-31 21:00:00.000000000 -0300
+++ nvidia-graphics-drivers-edit/debian/dkms/patches/0019-kernel-5.16.patch	2023-10-29 16:26:15.000000000 -0300
@@ -0,0 +1,32 @@
+diff -ruN NVIDIA-Linux-x86_64-304.137p1/kernel/nv.h NVIDIA-Linux-x86_64-304.137p2/kernel/nv.h
+--- NVIDIA-Linux-x86_64-304.137p1/nv.h	2022-06-25 19:30:43.581238269 -0300
++++ NVIDIA-Linux-x86_64-304.137p2/nv.h	2022-06-25 19:33:17.514321580 -0300
+@@ -13,7 +13,12 @@
+ #define _NV_H_
+ 
+ #include <nvtypes.h>
++#include <linux/version.h>
++#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 16, 0)
++#include <linux/stdarg.h>
++#else
+ #include <stdarg.h>
++#endif
+ 
+ #if !defined(NV_MIN)
+ #define NV_MIN(_a,_b) ((_a) < (_b) ? (_a) : (_b))
+diff -ruN NVIDIA-Linux-x86_64-304.137p1/kernel/os-interface.h NVIDIA-Linux-x86_64-304.137p2/kernel/os-interface.h
+--- NVIDIA-Linux-x86_64-304.137p1/os-interface.h	2017-09-14 17:51:09.000000000 -0300
++++ NVIDIA-Linux-x86_64-304.137p2/os-interface.h	2022-06-25 19:32:47.680977591 -0300
+@@ -24,7 +24,12 @@
+ *                                                                           *
+ \***************************************************************************/
+ 
++#include <linux/version.h>
++#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 16, 0)
++#include <linux/stdarg.h>
++#else
+ #include <stdarg.h>
++#endif
+ 
+ /*
+  * Define away Microsoft compiler extensions when possible
diff -ruN nvidia-graphics-drivers/debian/dkms/patches/0020-kernel-5.17.patch nvidia-graphics-drivers-edit/debian/dkms/patches/0020-kernel-5.17.patch
--- nvidia-graphics-drivers/debian/dkms/patches/0020-kernel-5.17.patch	1969-12-31 21:00:00.000000000 -0300
+++ nvidia-graphics-drivers-edit/debian/dkms/patches/0020-kernel-5.17.patch	2023-10-29 20:20:27.000000000 -0300
@@ -0,0 +1,39 @@
+diff -ruN NVIDIA-Linux-x86_64-304.137p1/kernel/conftest.sh NVIDIA-Linux-x86_64-304.137p2/kernel/conftest.sh
+--- NVIDIA-Linux-x86_64-304.137p1/conftest.sh	2022-06-25 19:31:26.129237123 -0300
++++ NVIDIA-Linux-x86_64-304.137p2/conftest.sh	2022-06-25 19:42:29.192952695 -0300
+@@ -1500,7 +1500,11 @@
+             CODE="
+             #include <linux/proc_fs.h>
+             void conftest_PDE_DATA(void) {
++            #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 17, 0)
++                pde_data();
++            #else
+                 PDE_DATA();
++            #endif
+             }"
+ 
+             compile_check_conftest "$CODE" "NV_PDE_DATA_PRESENT" "" "functions"
+diff -ruN NVIDIA-Linux-x86_64-304.137p1/kernel/nv-procfs.c NVIDIA-Linux-x86_64-304.137p2/kernel/nv-procfs.c
+--- NVIDIA-Linux-x86_64-304.137p1/nv-procfs.c	2022-06-25 19:31:00.686046297 -0300
++++ NVIDIA-Linux-x86_64-304.137p2/nv-procfs.c	2022-06-25 19:47:04.739405781 -0300
+@@ -20,6 +20,7 @@
+ #include "nv-reg.h"
+ #include "patches.h"
+ #include "rmil.h"
++#include <linux/version.h>
+ 
+ static const char *__README_warning = \
+     "The NVIDIA graphics driver tries to detect potential problems\n"
+@@ -122,8 +123,12 @@
+     })
+ 
+ #if defined(NV_PDE_DATA_PRESENT)
++#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 17, 0)
+ # define NV_PDE_DATA(inode) PDE_DATA(inode)
+ #else
++# define NV_PDE_DATA(inode) pde_data(inode)
++#endif
++#else
+ # define NV_PDE_DATA(inode) PDE(inode)->data
+ #endif
+ 
diff -ruN nvidia-graphics-drivers/debian/dkms/patches/0021-kernel-5.18.patch nvidia-graphics-drivers-edit/debian/dkms/patches/0021-kernel-5.18.patch
--- nvidia-graphics-drivers/debian/dkms/patches/0021-kernel-5.18.patch	1969-12-31 21:00:00.000000000 -0300
+++ nvidia-graphics-drivers-edit/debian/dkms/patches/0021-kernel-5.18.patch	2023-10-29 16:26:15.000000000 -0300
@@ -0,0 +1,176 @@
+diff -ruN NVIDIA-Linux-x86_64-304.137p1/kernel/nv-acpi.c NVIDIA-Linux-x86_64-304.137p2/kernel/nv-acpi.c
+--- NVIDIA-Linux-x86_64-304.137p1/nv-acpi.c	2017-09-14 17:51:09.000000000 -0300
++++ NVIDIA-Linux-x86_64-304.137p2/nv-acpi.c	2022-06-25 21:35:03.106678042 -0300
+@@ -14,6 +14,7 @@
+ #include "os-interface.h"
+ #include "nv-linux.h"
+ #include "nv-reg.h"
++#include <linux/version.h>
+ 
+ #if defined(NV_LINUX_ACPI_EVENTS_SUPPORTED)
+ 
+@@ -574,7 +575,12 @@
+             if (!nvif_parent_gpu_handle) /* unknown error */
+                 break;
+             
+-            retVal = acpi_bus_get_device(nvif_parent_gpu_handle, &device);
++            #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 18, 0)
++             device = acpi_fetch_acpi_dev(nvif_parent_gpu_handle);
++             retVal = 0;
++            #else
++             retVal = acpi_bus_get_device(nvif_parent_gpu_handle, &device);
++            #endif
+ 
+             if (ACPI_FAILURE(retVal) || !device)
+                 break;
+@@ -648,8 +654,11 @@
+     if (nvif_parent_gpu_handle == NULL) 
+         return;
+ 
++#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 18, 0)
++    device = acpi_fetch_acpi_dev(nvif_parent_gpu_handle);
++#else
+     acpi_bus_get_device(nvif_parent_gpu_handle, &device);
+-
++#endif
+     nv_uninstall_notifier(device, nv_acpi_event);
+     nvif_parent_gpu_handle = NULL;
+ 
+@@ -1137,8 +1146,13 @@
+     if (!dev_handle)
+         return RM_ERR_INVALID_ARGUMENT;
+ 
++#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 18, 0)
++    device = acpi_fetch_acpi_dev(dev_handle);
++    status = 0;
++#else
+     status = acpi_bus_get_device(dev_handle, &device);
+-
++#endif
++    
+     if (ACPI_FAILURE(status) || !device)
+         return RM_ERR_INVALID_ARGUMENT;
+ 
+diff -ruN NVIDIA-Linux-x86_64-304.137p1/kernel/nv.c NVIDIA-Linux-x86_64-304.137p2/kernel/nv.c
+--- NVIDIA-Linux-x86_64-304.137p1/nv.c	2022-06-25 19:31:10.540509042 -0300
++++ NVIDIA-Linux-x86_64-304.137p2/nv.c	2022-06-25 23:14:04.196971200 -0300
+@@ -20,8 +20,12 @@
+ #include <linux/version.h>
+ 
+ #if defined(MODULE_LICENSE)
++#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 9, 0)
++MODULE_LICENSE("GPL");
++#else
+ MODULE_LICENSE("NVIDIA");
+ #endif
++#endif
+ #if defined(MODULE_INFO)
+ MODULE_INFO(supported, "external");
+ #endif
+diff -ruN NVIDIA-Linux-x86_64-304.137p1/kernel/nv-linux.h NVIDIA-Linux-x86_64-304.137p2/kernel/nv-linux.h
+--- NVIDIA-Linux-x86_64-304.137p1/nv-linux.h	2022-06-25 19:31:29.893412239 -0300
++++ NVIDIA-Linux-x86_64-304.137p2/nv-linux.h	2022-06-25 22:04:11.236764184 -0300
+@@ -338,8 +338,13 @@
+ 
+ #if defined(NV_PCI_DMA_MAPPING_ERROR_PRESENT)
+ #if (NV_PCI_DMA_MAPPING_ERROR_ARGUMENT_COUNT == 2)
++#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 18, 0)
++#define NV_PCI_DMA_MAPPING_ERROR(dev, addr) \
++    dma_mapping_error(dev, addr)
++#else
+ #define NV_PCI_DMA_MAPPING_ERROR(dev, addr) \
+     pci_dma_mapping_error(dev, addr)
++#endif
+ #elif (NV_PCI_DMA_MAPPING_ERROR_ARGUMENT_COUNT == 1)
+ #define NV_PCI_DMA_MAPPING_ERROR(dev, addr) \
+     pci_dma_mapping_error(addr)
+diff -ruN NVIDIA-Linux-x86_64-304.137p1/kernel/nv-mlock.c NVIDIA-Linux-x86_64-304.137p2/kernel/nv-mlock.c
+--- NVIDIA-Linux-x86_64-304.137p1/nv-mlock.c	2022-06-25 19:31:08.052392389 -0300
++++ NVIDIA-Linux-x86_64-304.137p2/nv-mlock.c	2022-06-25 23:01:54.616935166 -0300
+@@ -13,6 +13,7 @@
+ 
+ #include "os-interface.h"
+ #include "nv-linux.h"
++#include <linux/version.h>
+ 
+ RM_STATUS NV_API_CALL nv_lock_user_pages(
+     nv_state_t *nv,
+@@ -76,6 +77,21 @@
+ 
+     for (i = 0; i < page_count; i++)
+     {
++#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 18, 0)
++        pte_array[i] = dma_map_page(&dev->dev, user_pages[i], 0,
++                PAGE_SIZE,
++                DMA_BIDIRECTIONAL);
++        if (NV_PCI_DMA_MAPPING_ERROR(&dev->dev, pte_array[i]))
++        {
++            nv_printf(NV_DBG_ERRORS,
++                    "NVRM: failed to create a DMA mapping!\n");
++            for (j = 0; j < i; j++)
++            {
++                dma_unmap_page(&dev->dev, pte_array[j],
++                        PAGE_SIZE, DMA_BIDIRECTIONAL);
++                put_page(user_pages[j]);
++            }
++#else
+         pte_array[i] = pci_map_page(dev, user_pages[i], 0,
+                 PAGE_SIZE,
+                 PCI_DMA_BIDIRECTIONAL);
+@@ -89,6 +105,7 @@
+                         PAGE_SIZE, PCI_DMA_BIDIRECTIONAL);
+                 put_page(user_pages[j]);
+             }
++#endif
+             os_free_mem(user_pages);
+             return RM_ERR_OPERATING_SYSTEM;
+         }
+@@ -117,8 +134,13 @@
+ 
+     for (i = 0; i < page_count; i++)
+     {
++#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 18, 0)
++        dma_unmap_page(&dev->dev, pte_array[i],
++                PAGE_SIZE, DMA_BIDIRECTIONAL);
++#else
+         pci_unmap_page(dev, pte_array[i],
+                 PAGE_SIZE, PCI_DMA_BIDIRECTIONAL);
++#endif
+         if (write)
+             set_page_dirty_lock(user_pages[i]);
+         put_page(user_pages[i]);
+diff -ruN NVIDIA-Linux-x86_64-304.137p1/kernel/nv-vm.c NVIDIA-Linux-x86_64-304.137p2/kernel/nv-vm.c
+--- NVIDIA-Linux-x86_64-304.137p1/nv-vm.c	2017-09-14 17:51:09.000000000 -0300
++++ NVIDIA-Linux-x86_64-304.137p2/nv-vm.c	2022-06-25 21:36:04.876681090 -0300
+@@ -12,6 +12,7 @@
+ #include "os-interface.h"
+ #include "nv.h"
+ #include "nv-linux.h"
++#include <linux/version.h>
+ 
+ #define NV_DEFAULT_LIST_PAGE_COUNT 10
+ 
+@@ -205,7 +206,11 @@
+         ret = swiotlb_map_sg(&dev->dev, sg, 1, PCI_DMA_BIDIRECTIONAL);
+     else
+ #endif
++#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 18, 0)
++    ret = dma_map_sg(&dev->dev, sg, 1, DMA_BIDIRECTIONAL);
++#else
+         ret = pci_map_sg(dev, sg, 1, PCI_DMA_BIDIRECTIONAL);
++#endif
+     return ret;
+ }
+ 
+@@ -216,7 +221,11 @@
+         swiotlb_unmap_sg(&dev->dev, sg, 1, PCI_DMA_BIDIRECTIONAL);
+     else
+ #endif
++#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 18, 0)
++    dma_unmap_sg(&dev->dev, sg, 1, DMA_BIDIRECTIONAL);
++#else
+         pci_unmap_sg(dev, sg, 1, PCI_DMA_BIDIRECTIONAL);
++#endif
+ }
+ 
+ #define NV_MAP_SG_MAX_RETRIES 16
diff -ruN nvidia-graphics-drivers/debian/dkms/patches/0022-kernel-6.0.patch nvidia-graphics-drivers-edit/debian/dkms/patches/0022-kernel-6.0.patch
--- nvidia-graphics-drivers/debian/dkms/patches/0022-kernel-6.0.patch	1969-12-31 21:00:00.000000000 -0300
+++ nvidia-graphics-drivers-edit/debian/dkms/patches/0022-kernel-6.0.patch	2023-10-29 16:26:15.000000000 -0300
@@ -0,0 +1,153 @@
+diff -ruN NVIDIA-Linux-x86_64-304.137-no-compat32p2/kernel/nv-acpi.c NVIDIA-Linux-x86_64-304.137-no-compat32p1/kernel/nv-acpi.c
+--- NVIDIA-Linux-x86_64-304.137-no-compat32p2/nv-acpi.c	2022-10-11 18:32:25.806972254 -0300
++++ NVIDIA-Linux-x86_64-304.137-no-compat32p1/nv-acpi.c	2022-10-17 20:44:08.497414745 -0300
+@@ -175,6 +175,53 @@
+     return 0;
+ }
+ 
++#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
++static struct nv_acpi_add_enumerated_data {
++	nv_acpi_t *object;
++	int *counter;
++};
++static int nv_acpi_add_enumerated(struct acpi_device *dev, void *data)
++{
++    struct nv_acpi_add_enumerated_data *rcvd_data = data;
++    nv_acpi_t *pNvAcpiObject = rcvd_data->object;
++    int *device_counter = rcvd_data->counter;
++    acpi_status status = -1;
++    nv_acpi_integer_t device_id = 0;
++    if (!dev)
++        return 0;
++    if (*device_counter == NV_MAXNUM_DISPLAY_DEVICES) {
++        nv_printf(NV_DBG_ERRORS, 
++            "NVRM: nv_acpi_add: Total number of devices cannot exceed %d\n", 
++            NV_MAXNUM_DISPLAY_DEVICES);
++        return 1;
++    }
++    status =
++        acpi_evaluate_integer(dev->handle, "_ADR", NULL, &device_id);
++    if (ACPI_FAILURE(status))
++        /* Couldnt query device_id for this device */
++        return 0;
++
++    device_id = (device_id & 0xffff);
++
++    if ((device_id != 0x100) && /* Not a known CRT device-id */ 
++        (device_id != 0x200) && /* Not a known TV device-id */ 
++        (device_id != 0x0110) && (device_id != 0x0118) && (device_id != 0x0400) && /* Not an LCD*/
++        (device_id != 0x0111) && (device_id != 0x0120) && (device_id != 0x0300)) /* Not a known DVI device-id */ 
++    {
++        /* This isnt a known device Id. 
++           Do default switching on this system. */
++        pNvAcpiObject->default_display_mask = 1;
++        return 1;
++    }
++
++    pNvAcpiObject->pNvVideo[*device_counter].dev_id = device_id;
++    pNvAcpiObject->pNvVideo[*device_counter].dev_handle = dev->handle;
++
++    (*device_counter)++;
++    return 0;
++}
++#endif
++
+ static int nv_acpi_add(struct acpi_device *device)
+ {
+     /*
+@@ -187,8 +234,10 @@
+     union acpi_object control_argument_0 = { ACPI_TYPE_INTEGER };
+     struct acpi_object_list control_argument_list = { 0, NULL };
+     nv_stack_t *sp = NULL;
++#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 0, 0)
+     struct list_head *node, *next;
+     nv_acpi_integer_t device_id = 0;
++#endif
+     int device_counter = 0;
+ 
+     NV_KMEM_CACHE_ALLOC_STACK(sp);
+@@ -217,6 +266,7 @@
+ 
+     // grab handles to all the important nodes representing devices
+ 
++#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 0, 0)
+     list_for_each_safe(node, next, &device->children) 
+     {
+         struct acpi_device *dev =
+@@ -259,6 +309,14 @@
+ 
+     }
+ 
++#else
++    struct nv_acpi_add_enumerated_data data = {
++        .object = pNvAcpiObject,
++        .counter = &device_counter,
++    };
++    acpi_dev_for_each_child(device, nv_acpi_add_enumerated, &data);
++#endif
++
+     // arg 0, bits 1:0, 0 = enable events
+     control_argument_0.integer.type = ACPI_TYPE_INTEGER;
+     control_argument_0.integer.value = 0x0;
+@@ -1119,6 +1177,31 @@
+     return RM_OK;             
+ }
+ 
++#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 0, 0)
++static int nv_acpi_ddc_method_enumerated(struct acpi_device *dev, void *data)
++{
++    acpi_handle *lcd_dev_handle = data;
++    acpi_status status;
++    nv_acpi_integer_t device_id = 0;
++    if (!dev)
++        return 0;
++    status = acpi_evaluate_integer(dev->handle, "_ADR", NULL, &device_id);
++    if (ACPI_FAILURE(status))
++        /* Couldnt query device_id for this device */
++        return 0;
++
++    device_id = (device_id & 0xffff);
++
++    if ((device_id == 0x0110) || (device_id == 0x0118) || (device_id == 0x0400)) /* Only for an LCD*/
++    {
++        *lcd_dev_handle = dev->handle;
++        nv_printf(NV_DBG_INFO, "NVRM: %s Found LCD: %x\n", __FUNCTION__, device_id);
++        return 1;
++    }
++    return 0;
++}
++#endif
++
+ /*
+  * This function executes a _DDC ACPI method.
+  */
+@@ -1134,8 +1217,10 @@
+     union acpi_object *ddc;
+     union acpi_object ddc_arg0 = { ACPI_TYPE_INTEGER };
+     struct acpi_object_list input = { 1, &ddc_arg0 };
++#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 0, 0)
+     struct list_head *node, *next;
+     nv_acpi_integer_t device_id = 0;
++#endif
+     NvU32 i;
+     acpi_handle dev_handle  = NULL;
+     acpi_handle lcd_dev_handle  = NULL;
+@@ -1166,6 +1251,7 @@
+         return RM_ERR_NOT_SUPPORTED;
+     }
+ 
++#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 0, 0)
+     list_for_each_safe(node, next, &device->children) 
+     {
+         struct acpi_device *dev =
+@@ -1190,6 +1276,10 @@
+ 
+     }
+ 
++#else
++    acpi_dev_for_each_child(device, nv_acpi_ddc_method_enumerated, &lcd_dev_handle);
++#endif
++
+     if (lcd_dev_handle == NULL)
+     {
+         nv_printf(NV_DBG_INFO, "NVRM: %s LCD not found\n", __FUNCTION__);
diff -ruN nvidia-graphics-drivers/debian/dkms/patches/0023-kernel-6.2.patch nvidia-graphics-drivers-edit/debian/dkms/patches/0023-kernel-6.2.patch
--- nvidia-graphics-drivers/debian/dkms/patches/0023-kernel-6.2.patch	1969-12-31 21:00:00.000000000 -0300
+++ nvidia-graphics-drivers-edit/debian/dkms/patches/0023-kernel-6.2.patch	2023-10-29 16:26:15.000000000 -0300
@@ -0,0 +1,63 @@
+diff -ruN NVIDIA-Linux-x86_64-304.137p2/kernel/conftest.sh NVIDIA-Linux-x86_64-304.137p1/kernel/conftest.sh
+--- NVIDIA-Linux-x86_64-304.137p2/conftest.sh	2023-03-04 16:12:23.378417621 -0300
++++ NVIDIA-Linux-x86_64-304.137p1/conftest.sh	2023-03-04 16:26:01.880723368 -0300
+@@ -760,12 +760,19 @@
+ 
+             echo "$CONFTEST_PREAMBLE
+             #include <linux/acpi.h>
++            #include <linux/version.h>
+ 
+             acpi_op_remove conftest_op_remove_routine;
+ 
++            #if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 2, 0)
++            void conftest_acpi_device_ops_remove(struct acpi_device *device) {
++                conftest_op_remove_routine(device);
++            }
++            #else
+             int conftest_acpi_device_ops_remove(struct acpi_device *device) {
+                 return conftest_op_remove_routine(device);
+-            }" > conftest$$.c
++            }
++            #endif" > conftest$$.c
+ 
+             $CC $CFLAGS -c conftest$$.c > /dev/null 2>&1
+             rm -f conftest$$.c
+diff -ruN NVIDIA-Linux-x86_64-304.137p2/kernel/nv-acpi.c NVIDIA-Linux-x86_64-304.137p1/kernel/nv-acpi.c
+--- NVIDIA-Linux-x86_64-304.137p2/nv-acpi.c	2023-03-04 16:23:21.599488932 -0300
++++ NVIDIA-Linux-x86_64-304.137p1/nv-acpi.c	2023-03-04 16:28:43.281966408 -0300
+@@ -23,8 +23,12 @@
+ #if !defined(NV_ACPI_DEVICE_OPS_REMOVE_ARGUMENT_COUNT) || (NV_ACPI_DEVICE_OPS_REMOVE_ARGUMENT_COUNT == 2)
+ static int         nv_acpi_remove_two_args(struct acpi_device *device, int type);
+ #else
++#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 2, 0)
++static void        nv_acpi_remove_one_arg(struct acpi_device *device);
++#else
+ static int         nv_acpi_remove_one_arg(struct acpi_device *device);
+ #endif
++#endif
+ 
+ static void        nv_acpi_event           (acpi_handle, u32, void *);
+ static acpi_status nv_acpi_find_methods    (acpi_handle, u32, void *, void **);
+@@ -354,8 +358,12 @@
+ #if !defined(NV_ACPI_DEVICE_OPS_REMOVE_ARGUMENT_COUNT) || (NV_ACPI_DEVICE_OPS_REMOVE_ARGUMENT_COUNT == 2)
+ static int nv_acpi_remove_two_args(struct acpi_device *device, int type)
+ #else
++#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 2, 0)
++static void nv_acpi_remove_one_arg(struct acpi_device *device)
++#else
+ static int nv_acpi_remove_one_arg(struct acpi_device *device)
+ #endif
++#endif
+ {
+     /*
+      * This function will cause RM to relinquish control of the VGA ACPI device.
+@@ -405,7 +413,9 @@
+         device->driver_data = NULL;
+     }
+ 
++#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 2, 0)
+     return status;
++#endif
+ }
+ 
+ static void nv_acpi_event(acpi_handle handle, u32 event_type, void *data)
diff -ruN nvidia-graphics-drivers/debian/dkms/patches/0024-kernel-6.3.patch nvidia-graphics-drivers-edit/debian/dkms/patches/0024-kernel-6.3.patch
--- nvidia-graphics-drivers/debian/dkms/patches/0024-kernel-6.3.patch	1969-12-31 21:00:00.000000000 -0300
+++ nvidia-graphics-drivers-edit/debian/dkms/patches/0024-kernel-6.3.patch	2023-10-29 16:26:15.000000000 -0300
@@ -0,0 +1,73 @@
+diff -ruN orig/nv-linux.h patch/nv-linux.h
+--- orig/nv-linux.h	2023-04-25 18:13:45.486403893 +0000
++++ patch/nv-linux.h	2023-04-25 19:41:50.332617306 +0000
+@@ -1958,4 +1958,17 @@
+ }
+ #endif  /* !defined(NV_VMWARE) && defined(CONFIG_MTRR) */
+ 
++#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 3, 0)
++// Rel. commit "mm: introduce vma->vm_flags wrapper functions" (Suren Baghdasaryan, 26 Jan 2023)
++static inline void vm_flags_set(struct vm_area_struct *vma, vm_flags_t flags)
++{
++    vma->vm_flags |= flags;
++}
++
++static inline void vm_flags_clear(struct vm_area_struct *vma, vm_flags_t flags)
++{
++    vma->vm_flags &= ~flags;
++}
++#endif
++
+ #endif  /* _NV_LINUX_H_ */
+diff -ruN orig/nv-mmap.c patch/nv-mmap.c
+--- orig/nv-mmap.c	2023-04-25 18:13:54.771059672 +0000
++++ patch/nv-mmap.c	2023-04-25 20:03:43.072182643 +0000
+@@ -271,8 +271,8 @@
+ #if defined(NVCPU_X86) || defined(NVCPU_X86_64)
+         pgprot_val(vma->vm_page_prot) &= ~_PAGE_RW;
+ #endif
+-        vma->vm_flags &= ~VM_WRITE;
+-        vma->vm_flags &= ~VM_MAYWRITE;
++        vm_flags_clear(vma, VM_WRITE);
++        vm_flags_clear(vma, VM_MAYWRITE);
+     }
+ 
+     if (IS_REG_OFFSET(nv, NV_VMA_OFFSET(vma), NV_VMA_SIZE(vma)))
+@@ -292,7 +292,7 @@
+             goto done;
+         }
+ 
+-        vma->vm_flags |= VM_IO;
++        vm_flags_set(vma, VM_IO);
+     }
+     else if (IS_FB_OFFSET(nv, NV_VMA_OFFSET(vma), NV_VMA_SIZE(vma)))
+     {
+@@ -326,7 +326,7 @@
+             goto done;
+         }
+ 
+-        vma->vm_flags |= VM_IO;
++        vm_flags_set(vma, VM_IO);
+     }
+ #if defined(NVCPU_X86) || defined(NVCPU_X86_64)
+     else if (IS_AGP_OFFSET(nv, NV_VMA_OFFSET(vma), NV_VMA_SIZE(vma)))
+@@ -377,7 +377,7 @@
+         NV_PRINT_AT(NV_DBG_MEMINFO, at);
+         nv_vm_list_page_count(&at->page_table[i], pages);
+ 
+-        vma->vm_flags |= VM_IO;
++        vm_flags_set(vma, VM_IO);
+     }
+ #endif
+     else
+@@ -464,8 +464,8 @@
+         NV_PRINT_AT(NV_DBG_MEMINFO, at);
+         nv_vm_list_page_count(&at->page_table[i], pages);
+ 
+-        vma->vm_flags |= (VM_IO | VM_LOCKED | VM_RESERVED);
+-        vma->vm_flags |= (VM_DONTEXPAND | VM_DONTDUMP);
++        vm_flags_set(vma, VM_IO | VM_LOCKED | VM_RESERVED);
++        vm_flags_set(vma, VM_DONTEXPAND | VM_DONTDUMP);
+     }
+ 
+     NV_VMA_FILE(vma) = file;
diff -ruN nvidia-graphics-drivers/debian/dkms/patches/0025-kernel-6.5.patch nvidia-graphics-drivers-edit/debian/dkms/patches/0025-kernel-6.5.patch
--- nvidia-graphics-drivers/debian/dkms/patches/0025-kernel-6.5.patch	1969-12-31 21:00:00.000000000 -0300
+++ nvidia-graphics-drivers-edit/debian/dkms/patches/0025-kernel-6.5.patch	2023-10-29 16:26:15.000000000 -0300
@@ -0,0 +1,64 @@
+diff -ruN -x nv-mlock.c.edit NVIDIA-Linux-x86_64-304.137-no-compat32/kernel/nv-linux.h NVIDIA-Linux-x86_64-304.137-no-compat32-edit/kernel/nv-linux.h
+--- NVIDIA-Linux-x86_64-304.137-no-compat32/nv-linux.h	2023-09-06 12:41:39.784853778 -0300
++++ NVIDIA-Linux-x86_64-304.137-no-compat32-edit/nv-linux.h	2023-09-06 14:07:48.047058497 -0300
+@@ -1955,7 +1955,48 @@
+         #define NV_GET_USER_PAGES           get_user_pages
+         #define NV_GET_USER_PAGES_REMOTE    get_user_pages_remote
+     #else
+-        #include <linux/mm.h>
++// Rel. commit. "mm/gup: remove unused vmas parameter from get_user_pages()" (Lorenzo Stoakes, 14 May 2023)
++#if LINUX_VERSION_CODE >= KERNEL_VERSION(6, 5, 0)
++#include <linux/mm.h>
++
++static inline long NV_GET_USER_PAGES(unsigned long start,
++                                     unsigned long nr_pages,
++                                     int write,
++                                     int force,
++                                     struct page **pages,
++                                     struct vm_area_struct **vmas)
++{
++    unsigned int flags = 0;
++
++    if (write)
++        flags |= FOLL_WRITE;
++    if (force)
++        flags |= FOLL_FORCE;
++
++    return get_user_pages(start, nr_pages, flags, pages);
++}
++
++// Rel. commit. "mm/gup: remove unused vmas parameter from get_user_pages_remote()" (Lorenzo Stoakes, 14 May 2023)
++static inline long NV_GET_USER_PAGES_REMOTE(struct task_struct *tsk,
++                                            struct mm_struct *mm,
++                                            unsigned long start,
++                                            unsigned long nr_pages,
++                                            int write,
++                                            int force,
++                                            struct page **pages,
++                                            struct vm_area_struct **vmas)
++{
++    unsigned int flags = 0;
++
++    if (write)
++        flags |= FOLL_WRITE;
++    if (force)
++        flags |= FOLL_FORCE;
++
++    return get_user_pages(start, nr_pages, flags, pages);
++}
++#else
++    #include <linux/mm.h>
+ 
+         static inline long NV_GET_USER_PAGES(unsigned long start,
+                                              unsigned long nr_pages,
+@@ -2004,9 +2045,9 @@
+                                             pages, vmas);
+ 	#endif
+         #endif
+-
+         }
+     #endif
++    #endif
+ #else
+     #define NV_GET_USER_PAGES(start, nr_pages, write, force, pages, vmas) \
+         get_user_pages(current, current->mm, start, nr_pages, write, force, pages, vmas)
diff -ruN nvidia-graphics-drivers/debian/dkms/patches/linux54-extramodules.patch nvidia-graphics-drivers-edit/debian/dkms/patches/linux54-extramodules.patch
--- nvidia-graphics-drivers/debian/dkms/patches/linux54-extramodules.patch	1969-12-31 21:00:00.000000000 -0300
+++ nvidia-graphics-drivers-edit/debian/dkms/patches/linux54-extramodules.patch	2023-10-29 16:26:15.000000000 -0300
@@ -0,0 +1,327 @@
+diff -Naur a/conftest.sh b/conftest.sh
+--- a/conftest.sh
++++ b/conftest.sh
+@@ -187,6 +187,23 @@
+     if [ -n "$BUILD_PARAMS" ]; then
+         CFLAGS="$CFLAGS -D$BUILD_PARAMS"
+     fi
++
++    # Check if gcc supports asm goto and set CC_HAVE_ASM_GOTO if it does.
++    # Older kernels perform this check and set this flag in Kbuild, and since
++    # conftest.sh runs outside of Kbuild it ends up building without this flag.
++    # Starting with commit e9666d10a5677a494260d60d1fa0b73cc7646eb3 this test
++    # is done within Kconfig, and the preprocessor flag is no longer needed.
++
++    GCC_GOTO_SH="$SOURCES/build/gcc-goto.sh"
++
++    if [ -f "$GCC_GOTO_SH" ]; then
++        # Newer versions of gcc-goto.sh don't print anything on success, but
++        # this is okay, since it's no longer necessary to set CC_HAVE_ASM_GOTO
++        # based on the output of those versions of gcc-goto.sh.
++        if [ `/bin/sh "$GCC_GOTO_SH" "$CC"` = "y" ]; then
++            CFLAGS="$CFLAGS -DCC_HAVE_ASM_GOTO"
++        fi
++    fi
+ }
+ 
+ CONFTEST_PREAMBLE="#include \"conftest.h\"
+diff -Naur a/Makefile.kbuild b/Makefile.kbuild
+--- a/Makefile.kbuild
++++ b/Makefile.kbuild
+@@ -231,7 +231,7 @@
+ endif
+ 
+ KBUILD_PARAMS += KBUILD_VERBOSE=$(NV_VERBOSE)
+-KBUILD_PARAMS += -C $(KERNEL_SOURCES) SUBDIRS=$(PWD)
++KBUILD_PARAMS += -C $(KERNEL_SOURCES) M=$(PWD)
+ KBUILD_PARAMS += ARCH=$(ARCH)
+ 
+ #
+diff -Naur a/nv.c b/nv.c
+--- a/nv.c
++++ b/nv.c
+@@ -18,7 +18,7 @@
+ #include "nv-pat.h"
+ 
+ #if defined(MODULE_LICENSE)
+-MODULE_LICENSE("NVIDIA");
++MODULE_LICENSE("GPL");
+ #endif
+ #if defined(MODULE_INFO)
+ MODULE_INFO(supported, "external");
+@@ -301,7 +301,7 @@
+ #else
+ irqreturn_t   nv_kern_isr(int, void *);
+ #endif
+-void          nv_kern_rc_timer(unsigned long);
++void          nv_kern_rc_timer(struct timer_list *t);
+ #if defined(NV_PM_SUPPORT_OLD_STYLE_APM)
+ static int    nv_kern_apm_event(struct pm_dev *, pm_request_t, void *);
+ #endif
+@@ -2075,10 +2075,10 @@
+ }
+ 
+ void nv_kern_rc_timer(
+-    unsigned long data
++    struct timer_list *t
+ )
+ {
+-    nv_linux_state_t *nvl = (nv_linux_state_t *) data;
++    nv_linux_state_t *nvl = from_timer(nvl, t, rc_timer);
+     nv_state_t *nv = NV_STATE_PTR(nvl);
+ 
+     NV_CHECK_PCI_CONFIG_SPACE(nvl->timer_sp, nv, TRUE, TRUE, FALSE);
+@@ -3029,9 +3029,7 @@
+         return -1;
+ 
+     nv_printf(NV_DBG_INFO, "NVRM: initializing rc timer\n");
+-    init_timer(&nvl->rc_timer);
+-    nvl->rc_timer.function = nv_kern_rc_timer;
+-    nvl->rc_timer.data = (unsigned long) nv;
++    timer_setup(&nvl->rc_timer, nv_kern_rc_timer, 0);
+     nv->rc_timer_enabled = 1;
+     mod_timer(&nvl->rc_timer, jiffies + HZ); /* set our timeout for 1 second */
+     nv_printf(NV_DBG_INFO, "NVRM: rc timer initialized\n");
+diff -Naur a/nv-drm.c b/nv-drm.c
+--- a/nv-drm.c
++++ b/nv-drm.c
+@@ -94,7 +94,7 @@
+ };
+ 
+ static struct drm_driver nv_drm_driver = {
+-#if defined(DRIVER_LEGACY)
++#if defined(DRIVER_LEGACY) || LINUX_VERSION_CODE >= KERNEL_VERSION(5, 0, 0)
+     .driver_features = DRIVER_LEGACY,
+ #else
+     .driver_features = 0,
+@@ -102,9 +102,6 @@
+     .load = nv_drm_load,
+     .unload = nv_drm_unload,
+     .fops = &nv_drm_fops,
+-#if defined(NV_DRM_PCI_SET_BUSID_PRESENT)
+-    .set_busid = drm_pci_set_busid,
+-#endif
+ 
+     .name = "nvidia-drm",
+     .desc = "NVIDIA DRM driver",
+@@ -121,7 +118,7 @@
+ {
+     int ret = 0;
+ #if defined(NV_DRM_AVAILABLE)
+-    ret = drm_pci_init(&nv_drm_driver, pci_driver);
++    ret = drm_legacy_pci_init(&nv_drm_driver, pci_driver);
+ #endif
+     return ret;
+ }
+@@ -131,6 +128,6 @@
+ )
+ {
+ #if defined(NV_DRM_AVAILABLE)
+-    drm_pci_exit(&nv_drm_driver, pci_driver);
++    drm_legacy_pci_exit(&nv_drm_driver, pci_driver);
+ #endif
+ }
+diff -Naur a/nv.h b/nv.h
+--- a/nv.h
++++ b/nv.h
+@@ -465,27 +465,27 @@
+ 
+ #define NV_TIMERCMP(a, b, CMP)                                              \
+     (((a)->tv_sec == (b)->tv_sec) ?                                         \
+-        ((a)->tv_usec CMP (b)->tv_usec) : ((a)->tv_sec CMP (b)->tv_sec))
++        ((a)->tv_nsec CMP (b)->tv_nsec) : ((a)->tv_sec CMP (b)->tv_sec))
+ 
+ #define NV_TIMERADD(a, b, result)                                           \
+     {                                                                       \
+         (result)->tv_sec = (a)->tv_sec + (b)->tv_sec;                       \
+-        (result)->tv_usec = (a)->tv_usec + (b)->tv_usec;                    \
+-        if ((result)->tv_usec >= 1000000)                                   \
++        (result)->tv_nsec = (a)->tv_nsec + (b)->tv_nsec;                    \
++        if ((result)->tv_nsec >= NSEC_PER_SEC)                                   \
+         {                                                                   \
+             ++(result)->tv_sec;                                             \
+-            (result)->tv_usec -= 1000000;                                   \
++            (result)->tv_nsec -= NSEC_PER_SEC;                                   \
+         }                                                                   \
+     }
+ 
+ #define NV_TIMERSUB(a, b, result)                                           \
+     {                                                                       \
+         (result)->tv_sec = (a)->tv_sec - (b)->tv_sec;                       \
+-        (result)->tv_usec = (a)->tv_usec - (b)->tv_usec;                    \
+-        if ((result)->tv_usec < 0)                                          \
++        (result)->tv_nsec = (a)->tv_nsec - (b)->tv_nsec;                    \
++        if ((result)->tv_nsec < 0)                                          \
+         {                                                                   \
+           --(result)->tv_sec;                                               \
+-          (result)->tv_usec += 1000000;                                     \
++          (result)->tv_nsec += NSEC_PER_SEC;                                     \
+         }                                                                   \
+     }
+ 
+diff -Naur a/nv-linux.h b/nv-linux.h
+--- a/nv-linux.h
++++ b/nv-linux.h
+@@ -841,11 +841,18 @@
+                         0, 0, NULL, NULL);                      \
+     }
+ #elif (NV_KMEM_CACHE_CREATE_ARGUMENT_COUNT == 5)
++#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 16, 0)
++#define NV_KMEM_CACHE_CREATE(kmem_cache, name, type)            \
++    {                                                           \
++        kmem_cache = kmem_cache_create_usercopy(name, sizeof(type), 0, 0, 0, sizeof(type), NULL); \
++    }
++#else
+ #define NV_KMEM_CACHE_CREATE(kmem_cache, name, type)            \
+     {                                                           \
+         kmem_cache = kmem_cache_create(name, sizeof(type),      \
+                         0, 0, NULL);                            \
+     }
++#endif
+ #else
+ #error "NV_KMEM_CACHE_CREATE_ARGUMENT_COUNT value unrecognized!"
+ #endif
+@@ -977,12 +984,21 @@
+         __ret;                                               \
+      })
+ #elif (NV_SMP_CALL_FUNCTION_ARGUMENT_COUNT == 3)
++#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 3, 0)
+ #define NV_SMP_CALL_FUNCTION(func, info, wait)               \
+     ({                                                       \
+         int __ret = smp_call_function(func, info, wait);     \
+         __ret;                                               \
+      })
+ #else
++#define NV_SMP_CALL_FUNCTION(func, info, wait)               \
++    ({                                                       \
++        int __ret = 0;                                       \
++        smp_call_function(func, info, wait);                 \
++        __ret;                                               \
++     })
++#endif
++#else
+ #error "NV_SMP_CALL_FUNCTION_ARGUMENT_COUNT value unrecognized!"
+ #endif
+ #elif defined(CONFIG_SMP)
+@@ -997,12 +1013,21 @@
+         __ret;                                         \
+      })
+ #elif (NV_ON_EACH_CPU_ARGUMENT_COUNT == 3)
++#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 3, 0)
+ #define NV_ON_EACH_CPU(func, info, wait)               \
+     ({                                                 \
+         int __ret = on_each_cpu(func, info, wait);     \
+         __ret;                                         \
+      })
+ #else
++#define NV_ON_EACH_CPU(func, info, wait)               \
++    ({                                                 \
++        int __ret = 0;                                 \
++        on_each_cpu(func, info, wait);                 \
++        __ret;                                         \
++    })
++#endif
++#else
+ #error "NV_ON_EACH_CPU_ARGUMENT_COUNT value unrecognized!"
+ #endif
+ #elif !defined(KERNEL_2_4) && defined(CONFIG_SMP)
+diff -Naur a/os-interface.c b/os-interface.c
+--- a/os-interface.c
++++ b/os-interface.c
+@@ -662,12 +662,12 @@
+     NvU32 *useconds
+ )
+ {
+-    struct timeval tm;
++    struct timespec64 tm;
+ 
+-    do_gettimeofday(&tm);
++    ktime_get_real_ts64(&tm);
+ 
+     *seconds = tm.tv_sec;
+-    *useconds = tm.tv_usec;
++    *useconds = tm.tv_nsec / NSEC_PER_USEC;
+ 
+     return RM_OK;
+ }
+@@ -697,9 +697,9 @@
+     unsigned long usec;
+ 
+ #ifdef NV_CHECK_DELAY_ACCURACY
+-    struct timeval tm1, tm2;
++    struct timespec64 tm1, tm2;
+ 
+-    do_gettimeofday(&tm1);
++    ktime_get_real_ts64(&tm1);
+ #endif
+ 
+     if (in_irq() && (MicroSeconds > NV_MAX_ISR_DELAY_US))
+@@ -714,9 +714,9 @@
+         udelay(usec);
+ 
+ #ifdef NV_CHECK_DELAY_ACCURACY
+-    do_gettimeofday(&tm2);
++    ktime_get_real_ts64(&tm2);
+     nv_printf(NV_DBG_ERRORS, "NVRM: osDelayUs %d: 0x%x 0x%x\n",
+-        MicroSeconds, tm2.tv_sec - tm1.tv_sec, tm2.tv_usec - tm1.tv_usec);
++        MicroSeconds, tm2.tv_sec - tm1.tv_sec, tm2.tv_nsec - tm1.tv_nsec);
+ #endif
+ 
+     return RM_OK;
+@@ -737,12 +737,12 @@
+     unsigned long MicroSeconds;
+     unsigned long jiffies;
+     unsigned long mdelay_safe_msec;
+-    struct timeval tm_end, tm_aux;
++    struct timespec64 tm_end, tm_aux;
+ #ifdef NV_CHECK_DELAY_ACCURACY
+-    struct timeval tm_start;
++    struct timespec64 tm_start;
+ #endif
+ 
+-    do_gettimeofday(&tm_aux);
++    ktime_get_real_ts64(&tm_aux);
+ #ifdef NV_CHECK_DELAY_ACCURACY
+     tm_start = tm_aux;
+ #endif
+@@ -757,7 +757,7 @@
+     }
+ 
+     MicroSeconds = MilliSeconds * 1000;
+-    tm_end.tv_usec = MicroSeconds;
++    tm_end.tv_nsec = MicroSeconds * NSEC_PER_USEC;
+     tm_end.tv_sec = 0;
+     NV_TIMERADD(&tm_aux, &tm_end, &tm_end);
+ 
+@@ -776,14 +776,14 @@
+         do
+         {
+             schedule_timeout(jiffies);
+-            do_gettimeofday(&tm_aux);
++            ktime_get_real_ts64(&tm_aux);
+             if (NV_TIMERCMP(&tm_aux, &tm_end, <))
+             {
+                 NV_TIMERSUB(&tm_end, &tm_aux, &tm_aux);
+-                MicroSeconds = tm_aux.tv_usec + tm_aux.tv_sec * 1000000;
++                MicroSeconds = tm_aux.tv_nsec / NSEC_PER_USEC + tm_aux.tv_sec * USEC_PER_SEC;
+             }
+             else
+-                MicroSeconds = 0;
++               MicroSeconds = 0;
+         } while ((jiffies = NV_USECS_TO_JIFFIES(MicroSeconds)) != 0);
+     }
+ 
+@@ -798,10 +798,10 @@
+         udelay(MicroSeconds);
+     }
+ #ifdef NV_CHECK_DELAY_ACCURACY
+-    do_gettimeofday(&tm_aux);
++    ktime_get_real_ts64(&tm_aux);
+     timersub(&tm_aux, &tm_start, &tm_aux);
+-    nv_printf(NV_DBG_ERRORS, "NVRM: osDelay %dmsec: %d.%06dsec\n",
+-        MilliSeconds, tm_aux.tv_sec, tm_aux.tv_usec);
++    nv_printf(NV_DBG_ERRORS, "NVRM: osDelay %dmsec: %d.%09dsec\n",
++        MilliSeconds, tm_aux.tv_sec, tm_aux.tv_nsec);
+ #endif
+ 
+     return RM_OK;
diff -ruN nvidia-graphics-drivers/debian/dkms.conf nvidia-graphics-drivers-edit/debian/dkms.conf
--- nvidia-graphics-drivers/debian/dkms.conf	2023-10-29 23:13:11.650261364 -0300
+++ nvidia-graphics-drivers-edit/debian/dkms.conf	2023-10-29 23:07:26.000000000 -0300
@@ -3,11 +3,38 @@
 CLEAN="make clean"
 BUILT_MODULE_NAME[0]="nvidia"
 DEST_MODULE_NAME[0]="nvidia_304"
-MAKE[0]="make module KERNDIR=/lib/modules/$kernelver IGNORE_XEN_PRESENCE=1 IGNORE_CC_MISMATCH=1 SYSSRC=$kernel_source_dir LD=/usr/bin/ld.bfd"
+MAKE[0]="[ ! -h /usr/bin/cc ] && export CC=/usr/bin/gcc; make module KERNDIR=/lib/modules/$kernelver IGNORE_XEN_PRESENCE=1 IGNORE_CC_MISMATCH=1 SYSSRC=$kernel_source_dir LD=/usr/bin/ld.bfd"
 DEST_MODULE_LOCATION[0]="/kernel/drivers/char/drm"
 AUTOINSTALL="yes"
-PATCH[0]="allow_sublevel_greater_than_5.patch"
-PATCH[1]="buildfix_kernel_4.14.patch"
+PATCH[0]=0001-disable-mtrr-4.3.patch 
+PATCH[1]=0002-pud-offset-4.12.patch
+PATCH[2]=0003-nvidia-drm-pci-init-4.14.patch
+PATCH[3]=0004-timer-4.15.patch
+PATCH[4]=0005-usercopy-4.16.patch
+PATCH[5]=0006-do_gettimeofday-5.0.patch
+PATCH[6]=0007-subdirs-5.3.patch
+PATCH[7]=0008-on-each-cpu-5.3.patch
+PATCH[8]=0009-remove-drmp-5.5.patch
+PATCH[9]=0010-proc-ops-5.6.patch
+PATCH[10]=0011-kernel-5.7.0-setmemoryarray.patch
+PATCH[11]=0012-kernel5.8.patch
+PATCH[12]=0013-kernel5.9.patch
+PATCH[13]=0014-import-drm_legacy_pci_init-exit-from-src-linux-5.9.1.patch
+PATCH[14]=0015-add-static-and-nv_-prefix-to-copied-drm-legacy-bits.patch
+PATCH[15]=0016-vmalloc5.9.patch
+PATCH[16]=0017-patch-14-kernel-5.11.patch
+PATCH[17]=0018-kernel5.14.patch
+PATCH[18]=0019-fix-mistake.patch
+PATCH[19]=0019-kernel-5.16.patch
+PATCH[20]=0020-kernel-5.17.patch
+PATCH[21]=0021-kernel-5.18.patch
+PATCH[22]=0022-kernel-6.0.patch
+PATCH[23]=0023-kernel-6.2.patch
+PATCH[24]=0024-kernel-6.3.patch
+PATCH[25]=0025-kernel-6.5.patch
+#PATCH[0]="linux54-extramodules.patch"
+#PATCH[0]="allow_sublevel_greater_than_5.patch"
+#PATCH[1]="buildfix_kernel_4.14.patch"
 #PATCH[1]="buildfix_kernel_4.9.patch"
 #PATCH[2]="buildfix_kernel_4.10.patch"
 #PATCH[3]="buildfix_kernel_4.11.patch"
diff -ruN nvidia-graphics-drivers/debian/glamor.conf nvidia-graphics-drivers-edit/debian/glamor.conf
--- nvidia-graphics-drivers/debian/glamor.conf	2023-10-29 23:13:11.650261364 -0300
+++ nvidia-graphics-drivers-edit/debian/glamor.conf	1969-12-31 21:00:00.000000000 -0300
@@ -1,3 +0,0 @@
-Section "Module"
-	Disable  "glamoregl"
-EndSection
diff -ruN nvidia-graphics-drivers/debian/nvidia-304.install nvidia-graphics-drivers-edit/debian/nvidia-304.install
--- nvidia-graphics-drivers/debian/nvidia-304.install	2023-10-29 23:13:11.654261194 -0300
+++ nvidia-graphics-drivers-edit/debian/nvidia-304.install	2023-10-29 23:07:26.000000000 -0300
@@ -2,7 +2,6 @@
 #Blacklist some card ids from GRUB gfxpayload=keep
 debian/nvidia-304.grub-gfxpayload          /usr/share/nvidia-304
 
-debian/glamor.conf                           /usr/share/nvidia-304
 
 debian/71-nvidia.rules                       lib/udev/rules.d
 
diff -ruN nvidia-graphics-drivers/debian/nvidia-304.postinst nvidia-graphics-drivers-edit/debian/nvidia-304.postinst
--- nvidia-graphics-drivers/debian/nvidia-304.postinst	2023-10-29 23:13:11.654261194 -0300
+++ nvidia-graphics-drivers-edit/debian/nvidia-304.postinst	2023-10-29 23:07:26.000000000 -0300
@@ -149,16 +149,16 @@
 	    --install /etc/ld.so.conf.d/i386-linux-gnu_GL.conf i386-linux-gnu_gl_conf /usr/lib/nvidia-304/alt_ld.so.conf 9701
 
         # Make sure glamoregl is disabled
-        update-alternatives --force \
-            --install /usr/share/X11/xorg.conf.d/glamoregl.conf glamor_conf \
-            /usr/share/nvidia-304/glamor.conf 600
+        #update-alternatives --force \
+        #    --install /usr/share/X11/xorg.conf.d/glamoregl.conf glamor_conf \
+        #    /usr/share/nvidia-304/glamor.conf 600
 
         # ldconfig needs to be run immediately as we're changing /etc/ld.so.conf.d/ with
         # alternatives.
         LDCONFIG_NOTRIGGER=y ldconfig
 
         CURRENT_KERNEL=$(uname -r)
-        NEWEST_KERNEL=$(get_newest_kernel "$KERNELS")
+        NEWEST_KERNEL=$(get_newest_kernel "$CURRENT_KERNEL")
 
         ALTERNATIVE=$(readlink /etc/alternatives/x86_64-linux-gnu_gl_conf)
         if [ "$ALTERNATIVE" = "/usr/lib/nvidia-304/ld.so.conf" ]; then
diff -ruN nvidia-graphics-drivers/debian/nvidia-304.prerm nvidia-graphics-drivers-edit/debian/nvidia-304.prerm
--- nvidia-graphics-drivers/debian/nvidia-304.prerm	2023-10-29 23:13:11.654261194 -0300
+++ nvidia-graphics-drivers-edit/debian/nvidia-304.prerm	2023-10-29 23:07:27.000000000 -0300
@@ -25,7 +25,7 @@
 	
 		update-alternatives --remove x86_64-linux-gnu_gl_conf /usr/lib/nvidia-304/ld.so.conf
 		update-alternatives --remove i386-linux-gnu_gl_conf /usr/lib/nvidia-304/alt_ld.so.conf
-		update-alternatives --remove glamor_conf /usr/share/nvidia-304/glamor.conf
+		#update-alternatives --remove glamor_conf /usr/share/nvidia-304/glamor.conf
 
 		# explicit ldconfig due to alternatives
 		ldconfig
diff -ruN nvidia-graphics-drivers/debian/rules nvidia-graphics-drivers-edit/debian/rules
--- nvidia-graphics-drivers/debian/rules	2023-10-29 23:13:11.654261194 -0300
+++ nvidia-graphics-drivers-edit/debian/rules	2023-10-29 17:01:41.000000000 -0300
@@ -7,7 +7,7 @@
 # nvidia packaging scripts and on Ubuntu's fglrx scripts.
 
 # Uncomment this to turn on verbose mode.
-#export DH_VERBOSE=1
+export DH_VERBOSE=1
 
 include /usr/share/cdbs/1/rules/debhelper.mk
 
@@ -273,7 +273,13 @@
 		cp -f $(CURDIR)/debian/temp/modules/nvidia-kernel/kernel/Makefile.kbuild \
 		$(CURDIR)/debian/temp/modules/nvidia-kernel/kernel/Makefile ; \
 	fi;
-
+	
+	# Remove the dkms.conf(s) from upstream
+	find $(CURDIR)/debian/temp/modules/nvidia-kernel/ -name dkms.conf* | xargs rm -f
+	
+	#mkdir -p $(CURDIR)/debian/dkms_nvidia
+	cp -f $(CURDIR)/debian/dkms.conf $(CURDIR)/debian/temp/modules/nvidia-kernel/dkms.conf
+	
 	# Disable the stack markings of binaries for security reasons.
 	# See (LP: #409456)
 	find $(CURDIR)/$(dirname) -name *.so* | xargs -n1 execstack -c
diff -ruN nvidia-graphics-drivers/debian/templates/control.in nvidia-graphics-drivers-edit/debian/templates/control.in
--- nvidia-graphics-drivers/debian/templates/control.in	2023-10-29 23:13:11.654261194 -0300
+++ nvidia-graphics-drivers-edit/debian/templates/control.in	2023-10-29 17:06:34.000000000 -0300
@@ -12,7 +12,7 @@
 Package: #DRIVERNAME#
 Architecture: i386 amd64
 Depends: x11-common (>= 1:7.0.0), make, sed (>> 3.0), dkms, linux-libc-dev, libc6-dev,
- patch, acpid, lib32gcc1 [amd64], libc6-i386 [amd64],
+ patch, acpid, lib32gcc-s1 [amd64], libc6-i386 [amd64],
  xserver-xorg-legacy, ${shlibs:Depends}, ${misc:Depends}, ${xviddriver:Depends}
 Recommends: nvidia-settings (>= 331.20),
  #LIBCUDA1#, #OPENCLICD#
@@ -62,24 +62,9 @@
  Supported NVIDIA devices include GPUs starting from GeForce 8 and Quadro FX
  series, as well as the Tesla computing processors.
 
-Package: #LIBOPENCL1#
-Architecture: i386 amd64
-Depends: ${shlibs:Depends}, ${misc:Depends}
-Conflicts: libopencl1
-Replaces: libopencl1
-Provides: libopencl1
-Suggests: #OPENCLICD#
-Description: NVIDIA OpenCL Driver and ICD Loader library
- OpenCL (Open Computing Language) is a multivendor open standard for
- general-purpose parallel programming of heterogeneous systems that include
- CPUs, GPUs and other processors.
- .
- This package contains NVIDIA's OpenCL implementation and the ICD Loader
- library. This library supports only OpenCL 1.1.
-
 Package: #OPENCLICD#
 Architecture: i386 amd64
-Depends: ${shlibs:Depends}, ${misc:Depends}, ocl-icd-libopencl1 | #LIBOPENCL1#
+Depends: ${shlibs:Depends}, ${misc:Depends}, ocl-icd-libopencl1
 Enhances: libopencl1
 Conflicts: nvidia-opencl-icd
 Replaces: nvidia-opencl-icd
@@ -106,13 +91,6 @@
  This is a transitional package for #DRIVERDEVNAME#, and can be
  safely removed after the installation is complete.
 
-Package: nvidia-libopencl1-304-updates
-Architecture: i386 amd64
-Depends: #LIBOPENCL1#
-Description: Transitional package for #LIBOPENCL1#
- This is a transitional package for #LIBOPENCL1#, and can be
- safely removed after the installation is complete.
-
 Package: nvidia-opencl-icd-304-updates
 Architecture: i386 amd64
 Depends: #OPENCLICD#
diff -ruN nvidia-graphics-drivers/debian/templates/dkms.conf.in nvidia-graphics-drivers-edit/debian/templates/dkms.conf.in
--- nvidia-graphics-drivers/debian/templates/dkms.conf.in	2023-10-29 23:13:11.654261194 -0300
+++ nvidia-graphics-drivers-edit/debian/templates/dkms.conf.in	2023-10-29 20:15:43.000000000 -0300
@@ -3,11 +3,38 @@
 CLEAN="make clean"
 BUILT_MODULE_NAME[0]="nvidia"
 DEST_MODULE_NAME[0]="#MODULENAME#"
-MAKE[0]="make module KERNDIR=/lib/modules/$kernelver IGNORE_XEN_PRESENCE=1 IGNORE_CC_MISMATCH=1 SYSSRC=$kernel_source_dir LD=/usr/bin/ld.bfd"
+MAKE[0]="[ ! -h /usr/bin/cc ] && export CC=/usr/bin/gcc; make module KERNDIR=/lib/modules/$kernelver IGNORE_XEN_PRESENCE=1 IGNORE_CC_MISMATCH=1 SYSSRC=$kernel_source_dir LD=/usr/bin/ld.bfd"
 DEST_MODULE_LOCATION[0]="/kernel/drivers/char/drm"
 AUTOINSTALL="yes"
-PATCH[0]="allow_sublevel_greater_than_5.patch"
-PATCH[1]="buildfix_kernel_4.14.patch"
+PATCH[0]=0001-disable-mtrr-4.3.patch 
+PATCH[1]=0002-pud-offset-4.12.patch
+PATCH[2]=0003-nvidia-drm-pci-init-4.14.patch
+PATCH[3]=0004-timer-4.15.patch
+PATCH[4]=0005-usercopy-4.16.patch
+PATCH[5]=0006-do_gettimeofday-5.0.patch
+PATCH[6]=0007-subdirs-5.3.patch
+PATCH[7]=0008-on-each-cpu-5.3.patch
+PATCH[8]=0009-remove-drmp-5.5.patch
+PATCH[9]=0010-proc-ops-5.6.patch
+PATCH[10]=0011-kernel-5.7.0-setmemoryarray.patch
+PATCH[11]=0012-kernel5.8.patch
+PATCH[12]=0013-kernel5.9.patch
+PATCH[13]=0014-import-drm_legacy_pci_init-exit-from-src-linux-5.9.1.patch
+PATCH[14]=0015-add-static-and-nv_-prefix-to-copied-drm-legacy-bits.patch
+PATCH[15]=0016-vmalloc5.9.patch
+PATCH[16]=0017-patch-14-kernel-5.11.patch
+PATCH[17]=0018-kernel5.14.patch
+PATCH[18]=0019-fix-mistake.patch
+PATCH[19]=0019-kernel-5.16.patch
+PATCH[20]=0020-kernel-5.17.patch
+PATCH[21]=0021-kernel-5.18.patch
+PATCH[22]=0022-kernel-6.0.patch
+PATCH[23]=0023-kernel-6.2.patch
+PATCH[24]=0024-kernel-6.3.patch
+PATCH[25]=0025-kernel-6.5.patch
+#PATCH[0]="linux54-extramodules.patch"
+#PATCH[0]="allow_sublevel_greater_than_5.patch"
+#PATCH[1]="buildfix_kernel_4.14.patch"
 #PATCH[1]="buildfix_kernel_4.9.patch"
 #PATCH[2]="buildfix_kernel_4.10.patch"
 #PATCH[3]="buildfix_kernel_4.11.patch"
diff -ruN nvidia-graphics-drivers/debian/templates/nvidia-graphics-drivers.install.in nvidia-graphics-drivers-edit/debian/templates/nvidia-graphics-drivers.install.in
--- nvidia-graphics-drivers/debian/templates/nvidia-graphics-drivers.install.in	2023-10-29 23:13:11.656261110 -0300
+++ nvidia-graphics-drivers-edit/debian/templates/nvidia-graphics-drivers.install.in	2023-10-29 17:31:55.000000000 -0300
@@ -2,7 +2,6 @@
 #Blacklist some card ids from GRUB gfxpayload=keep
 debian/#DRIVERNAME#.grub-gfxpayload          #PKGDATADIR#
 
-debian/glamor.conf                           #PKGDATADIR#
 
 debian/71-nvidia.rules                       lib/udev/rules.d
 
diff -ruN nvidia-graphics-drivers/debian/templates/nvidia-graphics-drivers.postinst.in nvidia-graphics-drivers-edit/debian/templates/nvidia-graphics-drivers.postinst.in
--- nvidia-graphics-drivers/debian/templates/nvidia-graphics-drivers.postinst.in	2023-10-29 23:13:11.656261110 -0300
+++ nvidia-graphics-drivers-edit/debian/templates/nvidia-graphics-drivers.postinst.in	2023-10-29 22:53:28.000000000 -0300
@@ -149,16 +149,16 @@
 	    --install #SYSCONFDIR#/ld.so.conf.d/#OTHER_ARCH#_GL.conf #OTHER_ARCH#_gl_conf #ALTLDSOCONF# #ALTPRIORITY#
 
         # Make sure glamoregl is disabled
-        update-alternatives --force \
-            --install /usr/share/X11/xorg.conf.d/glamoregl.conf glamor_conf \
-            #PKGDATADIR#/glamor.conf 600
+        #update-alternatives --force \
+        #    --install /usr/share/X11/xorg.conf.d/glamoregl.conf glamor_conf \
+        #    #PKGDATADIR#/glamor.conf 600
 
         # ldconfig needs to be run immediately as we're changing /etc/ld.so.conf.d/ with
         # alternatives.
         LDCONFIG_NOTRIGGER=y ldconfig
 
         CURRENT_KERNEL=$(uname -r)
-        NEWEST_KERNEL=$(get_newest_kernel "$KERNELS")
+        NEWEST_KERNEL=$(get_newest_kernel "$CURRENT_KERNEL")
 
         ALTERNATIVE=$(readlink /etc/alternatives/#DEB_HOST_MULTIARCH#_gl_conf)
         if [ "$ALTERNATIVE" = "#LDSOCONF#" ]; then
diff -ruN nvidia-graphics-drivers/debian/templates/nvidia-graphics-drivers.prerm.in nvidia-graphics-drivers-edit/debian/templates/nvidia-graphics-drivers.prerm.in
--- nvidia-graphics-drivers/debian/templates/nvidia-graphics-drivers.prerm.in	2023-10-29 23:13:11.656261110 -0300
+++ nvidia-graphics-drivers-edit/debian/templates/nvidia-graphics-drivers.prerm.in	2023-10-29 17:32:21.000000000 -0300
@@ -25,7 +25,7 @@
 	
 		update-alternatives --remove #DEB_HOST_MULTIARCH#_gl_conf #LDSOCONF#
 		update-alternatives --remove #OTHER_ARCH#_gl_conf #ALTLDSOCONF#
-		update-alternatives --remove glamor_conf #PKGDATADIR#/glamor.conf
+		#update-alternatives --remove glamor_conf #PKGDATADIR#/glamor.conf
 
 		# explicit ldconfig due to alternatives
 		ldconfig
